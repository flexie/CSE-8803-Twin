<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.528">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Digital Twins for Physical Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
      <a href="../../index.html" class="sidebar-logo-link">
      <img src="../../images/digitaltwin.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
      <div class="sidebar-tools-main">
    <a href="https://flexie.github.io/CSE-8803-Twin/" title="GitHub" class="quarto-navigation-tool px-1" aria-label="GitHub"><i class="bi bi-github"></i></a>
</div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../syllabus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Syllabus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../goals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Goals</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../schedule.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Schedule</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../seminar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Seminar</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Final Project</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#particle-filters" id="toc-particle-filters" class="nav-link active" data-scroll-target="#particle-filters">Particle Filters</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#monte-carlo-sampling" id="toc-monte-carlo-sampling" class="nav-link" data-scroll-target="#monte-carlo-sampling">Monte Carlo Sampling</a></li>
  <li><a href="#generic-particle-filter-algorithm" id="toc-generic-particle-filter-algorithm" class="nav-link" data-scroll-target="#generic-particle-filter-algorithm">Generic Particle Filter Algorithm</a></li>
  <li><a href="#probability-distributions-via-monte-carlo" id="toc-probability-distributions-via-monte-carlo" class="nav-link" data-scroll-target="#probability-distributions-via-monte-carlo">Probability distributions via Monte Carlo</a></li>
  <li><a href="#the-particle-filter" id="toc-the-particle-filter" class="nav-link" data-scroll-target="#the-particle-filter">The Particle Filter</a>
  <ul class="collapse">
  <li><a href="#predict-step" id="toc-predict-step" class="nav-link" data-scroll-target="#predict-step">Predict Step</a></li>
  <li><a href="#update-step" id="toc-update-step" class="nav-link" data-scroll-target="#update-step">Update Step</a></li>
  <li><a href="#computing-the-state-estimate" id="toc-computing-the-state-estimate" class="nav-link" data-scroll-target="#computing-the-state-estimate">Computing the State Estimate</a></li>
  <li><a href="#particle-resampling" id="toc-particle-resampling" class="nav-link" data-scroll-target="#particle-resampling">Particle Resampling</a></li>
  </ul></li>
  <li><a href="#sir-filter---a-complete-example" id="toc-sir-filter---a-complete-example" class="nav-link" data-scroll-target="#sir-filter---a-complete-example">SIR Filter - A Complete Example</a>
  <ul class="collapse">
  <li><a href="#effect-of-sensor-errors-on-the-filter" id="toc-effect-of-sensor-errors-on-the-filter" class="nav-link" data-scroll-target="#effect-of-sensor-errors-on-the-filter">Effect of Sensor Errors on the Filter</a></li>
  </ul></li>
  <li><a href="#fill-in-observe-results-and-write-conclusions" id="toc-fill-in-observe-results-and-write-conclusions" class="nav-link" data-scroll-target="#fill-in-observe-results-and-write-conclusions">FILL IN: Observe results and write conclusions</a>
  <ul class="collapse">
  <li><a href="#filter-degeneracy-from-inadequate-samples" id="toc-filter-degeneracy-from-inadequate-samples" class="nav-link" data-scroll-target="#filter-degeneracy-from-inadequate-samples">Filter Degeneracy From Inadequate Samples</a></li>
  </ul></li>
  <li><a href="#fill-in-observe-results-and-write-conclusions-1" id="toc-fill-in-observe-results-and-write-conclusions-1" class="nav-link" data-scroll-target="#fill-in-observe-results-and-write-conclusions-1">FILL IN: Observe results and write conclusions</a></li>
  <li><a href="#fill-in-observe-results-and-write-conclusions-2" id="toc-fill-in-observe-results-and-write-conclusions-2" class="nav-link" data-scroll-target="#fill-in-observe-results-and-write-conclusions-2">FILL IN: Observe results and write conclusions</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<p><a href="./table_of_contents.ipynb">Table of Contents</a></p>
<section id="particle-filters" class="level1">
<h1>Particle Filters</h1>
<div id="cell-2" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-3" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install filterpy</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>unzip kf_book.<span class="bu">zip</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="cell-4" class="cell" data-outputid="de60f23b-38fd-4df8-e91a-563ef8591d95">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">#format the book</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#import book_format</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#book_format.set_style()</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">

        <style>
        .output_wrapper, .output {
            height:auto !important;
            max-height:100000px;
        }
        .output_scroll {
            box-shadow:none !important;
            webkit-box-shadow:none !important;
        }
        </style>
    
</div>
</div>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>Here is our problem. We have moving objects that we want to track. Maybe the objects are fighter jets and missiles, or maybe we are tracking people playing cricket in a field. It doesn’t really matter. Which of the filters that we have learned can handle this problem? Unfortunately, none of them are ideal. Let’s think about the characteristics of this problem.</p>
<ul>
<li><p><strong>multimodal</strong>: We want to track zero, one, or more than one object simultaneously.</p></li>
<li><p><strong>occlusions</strong>: One object can hide another, resulting in one measurement for multiple objects.</p></li>
<li><p><strong>nonlinear behavior</strong>: Aircraft are buffeted by winds, balls move in parabolas, and people collide into each other.</p></li>
<li><p><strong>nonlinear measurements</strong>: Radar gives us the distance to an object. Converting that to an (x,y,z) coordinate requires a square root, which is nonlinear.</p></li>
<li><p><strong>non-Gaussian noise:</strong> as objects move across a background the computer vision can mistake part of the background for the object.</p></li>
<li><p><strong>continuous:</strong> the object’s position and velocity (i.e.&nbsp;the state space) can smoothly vary over time.</p></li>
<li><p><strong>multivariate</strong>: we want to track several attributes, such as position, velocity, turn rates, etc.</p></li>
<li><p><strong>unknown process model</strong>: we may not know the process model of the system.</p></li>
</ul>
<p>None of the filters we have learned work well with all of these constraints.</p>
<ul>
<li><p><strong>Discrete Bayes filter</strong>: This has most of the attributes. It is multimodal, can handle nonlinear measurements, and can be extended to work with nonlinear behavior. However, it is discrete and univariate.</p></li>
<li><p><strong>Kalman filter</strong>: The Kalman filter produces optimal estimates for unimodal linear systems with Gaussian noise. None of these are true for our problem.</p></li>
<li><p><strong>Unscented Kalman filter</strong>: The UKF handles nonlinear, continuous, multivariate problems. However, it is not multimodal nor does it handle occlusions. It can handle noise that is modestly non-Gaussian, but does not do well with distributions that are very non-Gaussian or problems that are very nonlinear.</p></li>
<li><p><strong>Extended Kalman filter</strong>: The EKF has the same strengths and limitations as the UKF, except that is it even more sensitive to strong nonlinearities and non-Gaussian noise.</p></li>
</ul>
</section>
<section id="monte-carlo-sampling" class="level2">
<h2 class="anchored" data-anchor-id="monte-carlo-sampling">Monte Carlo Sampling</h2>
<p>In the UKF chapter I generated a plot similar to this to illustrate the effects of nonlinear systems on Gaussians:</p>
<div id="cell-7" class="cell" data-outputid="5e5c5c8f-1d0c-41fa-ec23-97b7b919958e">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">#import kf_book.pf_internal as pf_internal #version difference caused error here, dont worry about running this</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#pf_internal.plot_monte_carlo_ukf() #version difference caused error here, dont worry about running this</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Particle-Filters_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The left plot shows 3,000 points normally distributed based on the Gaussian</p>
<p><span class="math display">\[\mu = \begin{bmatrix}0\\0\end{bmatrix},\, \, \, \Sigma = \begin{bmatrix}32&amp;15\\15&amp;40\end{bmatrix}\]</span></p>
<p>The right plots shows these points passed through this set of equations:</p>
<p><span class="math display">\[\begin{aligned}x&amp;=x+y\\
y &amp;= 0.1x^2 + y^2\end{aligned}\]</span></p>
<p>Using a finite number of randomly sampled points to compute a result is called a <a href="https://en.wikipedia.org/wiki/Monte_Carlo_method"><em>Monte Carlo</em></a> (MC) method. The idea is simple. Generate enough points to get a representative sample of the problem, run the points through the system you are modeling, and then compute the results on the transformed points.</p>
<p>In a nutshell this is what particle filtering does. The Bayesian filter algorithm we have been using throughout the book is applied to thousands of particles, where each particle represents a <em>possible</em> state for the system. We extract the estimated state from the thousands of particles using weighted statistics of the particles.</p>
</section>
<section id="generic-particle-filter-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="generic-particle-filter-algorithm">Generic Particle Filter Algorithm</h2>
<ol type="1">
<li><strong>Randomly generate a bunch of particles</strong></li>
</ol>
<p>Particles can have position, heading, and/or whatever other state variable you need to estimate. Each has a weight (probability) indicating how likely it matches the actual state of the system. Initialize each with the same weight.</p>
<ol start="2" type="1">
<li><strong>Predict next state of the particles</strong></li>
</ol>
<p>Move the particles based on how you predict the real system is behaving.</p>
<ol start="3" type="1">
<li><strong>Update</strong></li>
</ol>
<p>Update the weighting of the particles based on the measurement. Particles that closely match the measurements are weighted higher than particles which don’t match the measurements very well.</p>
<ol start="4" type="1">
<li><strong>Resample</strong></li>
</ol>
<p>Discard highly improbable particle and replace them with copies of the more probable particles.</p>
<ol start="5" type="1">
<li><strong>Compute Estimate</strong></li>
</ol>
<p>Optionally, compute weighted mean and covariance of the set of particles to get a state estimate.</p>
<p>This naive algorithm has practical difficulties which we will need to overcome, but this is the general idea. Let’s see an example. I wrote a particle filter for the robot localization problem from the UKF and EKF chapters. The robot has steering and velocity control inputs. It has sensors that measures distance to visible landmarks. Both the sensors and control mechanism have noise in them, and we need to track the robot’s position.</p>
<p>Here I run a particle filter and plotted the positions of the particles. The plot on the left is after one iteration, and on the right is after 10. The red ‘X’ shows the actual position of the robot, and the large circle is the computed weighted mean position.</p>
<div id="cell-10" class="cell" data-outputid="6e8875f7-8af0-4dca-f887-84af460a110b">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pf_internal.show_two_pf_plots()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If you are viewing this in a browser, this animation shows the entire sequence:</p>
<p><img src="animations/particle_filter_anim.gif"></p>
<p>After the first iteration the particles are still largely randomly scattered around the map, but you can see that some have already collected near the robot’s position. The computed mean is quite close to the robot’s position. This is because each particle is weighted based on how closely it matches the measurement. The robot is near (1,1), so particles that are near (1, 1) will have a high weight because they closely match the measurements. Particles that are far from the robot will not match the measurements, and thus have a very low weight. The estimated position is computed as the weighted mean of positions of the particles. Particles near the robot contribute more to the computation so the estimate is quite accurate.</p>
<p>Several iterations later you can see that all the particles have clustered around the robot. This is due to the <em>resampling</em> step. Resampling discards particles that are very improbable (very low weight) and replaces them with particles with higher probability.</p>
<p>I haven’t fully shown <em>why</em> this works nor fully explained the algorithms for particle weighting and resampling, but it should make intuitive sense. Make a bunch of random particles, move them so they ‘kind of’ follow the robot, weight them according to how well they match the measurements, only let the likely ones live. It seems like it should work, and it does.</p>
</section>
<section id="probability-distributions-via-monte-carlo" class="level2">
<h2 class="anchored" data-anchor-id="probability-distributions-via-monte-carlo">Probability distributions via Monte Carlo</h2>
<p>Suppose we want to know the area under the curve <span class="math inline">\(y= \mathrm{e}^{\sin(x)}\)</span> in the interval [0, <span class="math inline">\(\pi\)</span>]. The area is computed with the definite integral <span class="math inline">\(\int_0^\pi \mathrm{e}^{\sin(x)}\, \mathrm{d}x\)</span>. As an exercise, go ahead and find the answer; I’ll wait.</p>
<p>If you are wise you did not take that challenge; <span class="math inline">\(\mathrm{e}^{\sin(x)}\)</span> cannot be integrated analytically. The world is filled with equations which we cannot integrate. For example, consider calculating the luminosity of an object. An object reflects some of the light that strike it. Some of the reflected light bounces off of other objects and restrikes the original object, increasing the luminosity. This creates a <em>recursive integral</em>. Good luck with that one.</p>
<p>However, integrals are trivial to compute using a Monte Carlo technique. To find the area under a curve create a bounding box that contains the curve in the desired interval. Generate randomly positioned point within the box, and compute the ratio of points that fall under the curve vs the total number of points. For example, if 40% of the points are under the curve and the area of the bounding box is 1, then the area under the curve is approximately 0.4. As you tend towards infinite points you can achieve any arbitrary precision. In practice, a few thousand points will give you a fairly accurate result.</p>
<p>You can use this technique to numerically integrate a function of any arbitrary difficulty. this includes non-integrable and noncontinuous functions. This technique was invented by Stanley Ulam at Los Alamos National Laboratory to allow him to perform computations for nuclear reactions which were unsolvable on paper.</p>
<p>Let’s compute <span class="math inline">\(\pi\)</span> by finding the area of a circle. We will define a circle with a radius of 1, and bound it in a square. The side of the square has length 2, so the area is 4. We generate a set of uniformly distributed random points within the box, and count how many fall inside the circle. The area of the circle is computed as the area of the box times the ratio of points inside the circle vs.&nbsp;the total number of points. Finally, we know that <span class="math inline">\(A = \pi r^2\)</span>, so we compute <span class="math inline">\(\pi = A / r^2\)</span>.</p>
<p>We start by creating the points.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">20000</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, (N, <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A point is inside a circle if its distance from the center of the circle is less than or equal to the radius. We compute the distance with <code>numpy.linalg.norm</code>, which computes the magnitude of a vector. Since vectors start at (0, 0) calling norm will compute the point’s distance from the origin.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> np.linalg.norm(pts, axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next we compute which of this distances fit the criteria. This code returns a bool array that contains <code>True</code> if it meets the condition <code>dist &lt;= 1</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>in_circle <span class="op">=</span> dist <span class="op">&lt;=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>All that is left is to count the points inside the circle, compute pi, and plot the results. I’ve put it all in one cell so you can experiment with alternative values for <code>N</code>, the number of points.</p>
<div id="cell-15" class="cell" data-outputid="5c700f00-b619-4b71-a3a1-e84ce456b1d2">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> uniform</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">20000</span>  <span class="co"># number of points</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>radius <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>area <span class="op">=</span> (<span class="dv">2</span><span class="op">*</span>radius)<span class="op">**</span><span class="dv">2</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>pts <span class="op">=</span> uniform(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, (N, <span class="dv">2</span>))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="co"># distance from (0,0)</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> np.linalg.norm(pts, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>in_circle <span class="op">=</span> dist <span class="op">&lt;=</span> <span class="dv">1</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>pts_in_circle <span class="op">=</span> np.count_nonzero(in_circle)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>pi <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> (pts_in_circle <span class="op">/</span> N)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co"># plot results</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>plt.scatter(pts[in_circle,<span class="dv">0</span>], pts[in_circle,<span class="dv">1</span>],</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            marker<span class="op">=</span><span class="st">','</span>, edgecolor<span class="op">=</span><span class="st">'k'</span>, s<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>plt.scatter(pts[<span class="op">~</span>in_circle,<span class="dv">0</span>], pts[<span class="op">~</span>in_circle,<span class="dv">1</span>],</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>            marker<span class="op">=</span><span class="st">','</span>, edgecolor<span class="op">=</span><span class="st">'r'</span>, s<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>plt.axis(<span class="st">'equal'</span>)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'mean pi(N=</span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">)= </span><span class="sc">{</span>pi<span class="sc">:.4f}</span><span class="ss">'</span>)</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'err  pi(N=</span><span class="sc">{</span>N<span class="sc">}</span><span class="ss">)= </span><span class="sc">{</span>np<span class="sc">.</span>pi<span class="op">-</span>pi<span class="sc">:.4f}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This insight leads us to the realization that we can use Monte Carlo to compute the probability density of any probability distribution. For example, suppose we have this Gaussian:</p>
<div id="cell-17" class="cell" data-outputid="834c4736-abe5-403a-c96c-090724b9a8a1">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> filterpy.stats <span class="im">import</span> plot_gaussian_pdf</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>plot_gaussian_pdf(mean<span class="op">=</span><span class="dv">2</span>, variance<span class="op">=</span><span class="dv">3</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The probability density function (PDF) gives the probability that the random value falls between 2 values. For example, we may want to know the probability of x being between 0 and 2 in the graph above. This is a continuous function, so we need to take the integral to find the area under the curve, as the area is equal to the probability for that range of values to occur.</p>
<p><span class="math display">\[P[a \le X \le b] = \int_a^b f_X(x) \, dx\]</span></p>
<p>It is easy to compute this integral for a Gaussian. But real life is not so easy. For example, the plot below shows a probability distribution. There is no way to analytically describe an arbitrary curve, let alone integrate it.</p>
<div id="cell-19" class="cell" data-outputid="f559da83-d1c5-4a0e-9c0d-11b37422d42a">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>pf_internal.plot_random_pd()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can use Monte Carlo methods to compute any integral. The PDF is computed with an integral, hence we can compute the PDF of this curve using Monte Carlo.</p>
</section>
<section id="the-particle-filter" class="level2">
<h2 class="anchored" data-anchor-id="the-particle-filter">The Particle Filter</h2>
<p>All of this brings us to the particle filter. Consider tracking a robot or a car in an urban environment. For consistency I will use the robot localization problem from the EKF and UKF chapters. In this problem we tracked a robot that has a sensor which measures the range and bearing to known landmarks.</p>
<p>Particle filters are a family of algorithms. I’m presenting a specific form of a particle filter that is intuitive to grasp and relates to the problems we have studied in this book. This will leave a few of the steps seeming a bit ‘magical’ since I haven’t offered a full explanation. That will follow later in the chapter.</p>
<p>Taking insight from the discussion in the previous section we start by creating several thousand <em>particles</em>. Each particle has a position that represents a possible belief of where the robot is in the scene, and perhaps a heading and velocity. Suppose that we have no knowledge of the location of the robot. We would want to scatter the particles uniformly over the entire scene. If you think of all of the particles representing a probability distribution, locations where there are more particles represent a higher belief, and locations with fewer particles represents a lower belief. If there was a large clump of particles near a specific location that would imply that we were more certain that the robot is there.</p>
<p>Each particle needs a weight - ideally the probability that it represents the true position of the robot. This probability is rarely computable, so we only require it be <em>proportional</em> to that probability, which is computable. At initialization we have no reason to favor one particle over another, so we assign a weight of <span class="math inline">\(1/N\)</span>, for <span class="math inline">\(N\)</span> particles. We use <span class="math inline">\(1/N\)</span> so that the sum of all probabilities equals one.</p>
<p>The combination of particles and weights forms the <em>probability distribution</em> for our problem. Think back to the <em>Discrete Bayes</em> chapter. In that chapter we modeled positions in a hallway as discrete and uniformly spaced. This is very similar except the particles are randomly distributed in a continuous space rather than constrained to discrete locations. In this problem the robot can move on a plane of some arbitrary dimension, with the lower right corner at (0,0).</p>
<p>To track our robot we need to maintain states for x, y, and heading. We will store <code>N</code> particles in a <code>(N, 3)</code> shaped array. The three columns contain x, y, and heading, in that order.</p>
<p>If you are passively tracking something (no control input), then you would need to include velocity in the state and use that estimate to make the prediction. More dimensions requires exponentially more particles to form a good estimate, so we always try to minimize the number of random variables in the state.</p>
<p>This code creates a uniform and Gaussian distribution of particles over a region:</p>
<div id="cell-22" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> uniform</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_uniform_particles(x_range, y_range, hdg_range, N):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    particles <span class="op">=</span> np.empty((N, <span class="dv">3</span>))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">0</span>] <span class="op">=</span> uniform(x_range[<span class="dv">0</span>], x_range[<span class="dv">1</span>], size<span class="op">=</span>N)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">1</span>] <span class="op">=</span> uniform(y_range[<span class="dv">0</span>], y_range[<span class="dv">1</span>], size<span class="op">=</span>N)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">2</span>] <span class="op">=</span> uniform(hdg_range[<span class="dv">0</span>], hdg_range[<span class="dv">1</span>], size<span class="op">=</span>N)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">2</span>] <span class="op">%=</span> <span class="dv">2</span> <span class="op">*</span> np.pi</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> particles</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_gaussian_particles(mean, std, N):</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    particles <span class="op">=</span> np.empty((N, <span class="dv">3</span>))</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">0</span>] <span class="op">=</span> mean[<span class="dv">0</span>] <span class="op">+</span> (randn(N) <span class="op">*</span> std[<span class="dv">0</span>])</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">1</span>] <span class="op">=</span> mean[<span class="dv">1</span>] <span class="op">+</span> (randn(N) <span class="op">*</span> std[<span class="dv">1</span>])</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">2</span>] <span class="op">=</span> mean[<span class="dv">2</span>] <span class="op">+</span> (randn(N) <span class="op">*</span> std[<span class="dv">2</span>])</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">2</span>] <span class="op">%=</span> <span class="dv">2</span> <span class="op">*</span> np.pi</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> particles</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>For example:</p>
<div id="cell-24" class="cell" data-outputid="44859b63-9950-4690-8cf7-50038ced8dea">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>create_uniform_particles((<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">0</span>, np.pi<span class="op">*</span><span class="dv">2</span>), <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>array([[0.772, 0.336, 4.171],
       [0.333, 0.34 , 4.319],
       [0.6  , 0.274, 5.02 ],
       [0.054, 0.022, 5.034]])</code></pre>
</div>
</div>
<section id="predict-step" class="level3">
<h3 class="anchored" data-anchor-id="predict-step">Predict Step</h3>
<p>The predict step in the Bayes algorithm uses the process model to update the belief in the system state. How would we do that with particles? Each particle represents a possible position for the robot. Suppose we send a command to the robot to move 0.1 meters while turning by 0.007 radians. We could move each particle by this amount. If we did that we would soon run into a problem. The robot’s controls are not perfect so it will not move exactly as commanded. Therefore we need to add noise to the particle’s movements to have a reasonable chance of capturing the actual movement of the robot. If you do not model the uncertainty in the system the particle filter will not correctly model the probability distribution of our belief in the robot’s position.</p>
<div id="cell-26" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(particles, u, std, dt<span class="op">=</span><span class="fl">1.</span>):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">""" move according to control input u (heading change, velocity)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">    with noise Q (std heading change, std velocity)`"""</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(particles)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># update heading</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">2</span>] <span class="op">+=</span> u[<span class="dv">0</span>] <span class="op">+</span> (randn(N) <span class="op">*</span> std[<span class="dv">0</span>])</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">2</span>] <span class="op">%=</span> <span class="dv">2</span> <span class="op">*</span> np.pi</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># move in the (noisy) commanded direction</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> (u[<span class="dv">1</span>] <span class="op">*</span> dt) <span class="op">+</span> (randn(N) <span class="op">*</span> std[<span class="dv">1</span>])</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">0</span>] <span class="op">+=</span> np.cos(particles[:, <span class="dv">2</span>]) <span class="op">*</span> dist</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    particles[:, <span class="dv">1</span>] <span class="op">+=</span> np.sin(particles[:, <span class="dv">2</span>]) <span class="op">*</span> dist</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="update-step" class="level3">
<h3 class="anchored" data-anchor-id="update-step">Update Step</h3>
<p>Next we get a set of measurements - one for each landmark currently in view. How should these measurements be used to alter our probability distribution as modeled by the particles?</p>
<p>Think back to the <strong>Discrete Bayes</strong> chapter. In that chapter we modeled positions in a hallway as discrete and uniformly spaced. We assigned a probability to each position which we called the <em>prior</em>. When a new measurement came in we multiplied the current probability of that position (the <em>prior</em>) by the <em>likelihood</em> that the measurement matched that location:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(likelihood, prior):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    posterior <span class="op">=</span> prior <span class="op">*</span> likelihood</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> normalize(posterior)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>which is an implementation of the equation</p>
<p><span class="math display">\[x = \| \mathcal L \bar x \|\]</span></p>
<p>which is a realization of Bayes theorem:</p>
<p><span class="math display">\[\begin{aligned}P(x \mid z) &amp;= \frac{P(z \mid x)\, P(x)}{P(z)} \\
&amp;= \frac{\mathtt{likelihood}\times \mathtt{prior}}{\mathtt{normalization}}\end{aligned}\]</span></p>
<p>We do the same with our particles. Each particle has a position and a weight which estimates how well it matches the measurement. Normalizing the weights so they sum to one turns them into a probability distribution. The particles those that are closest to the robot will generally have a higher weight than ones far from the robot.</p>
<div id="cell-29" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update(particles, weights, z, R, landmarks):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, landmark <span class="kw">in</span> <span class="bu">enumerate</span>(landmarks):</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        distance <span class="op">=</span> <span class="co">#FILL IN CODE! calculate norm between particles and landmark</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        weights <span class="op">*=</span> scipy.stats.norm(distance, R).pdf(z[i])</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">+=</span> <span class="fl">1.e-300</span>      <span class="co"># avoid round-off to zero</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">#FILL IN CODE! normalize so that they sum to one</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In the literature this part of the algorithm is called <em>Sequential Importance Sampling</em>, or SIS. The equation for the weights is called the <em>importance density</em>. I will give these theoretical underpinnings in a following section. For now I hope that this makes intuitive sense. If we weight the particles according to how well they match the measurements they are probably a good sample for the probability distribution of the system after incorporating the measurements. Theory proves this is so. The weights are the <em>likelihood</em> in Bayes theorem. Different problems will need to tackle this step in slightly different ways but this is the general idea.</p>
</section>
<section id="computing-the-state-estimate" class="level3">
<h3 class="anchored" data-anchor-id="computing-the-state-estimate">Computing the State Estimate</h3>
<p>In most applications you will want to know the estimated state after each update, but the filter consists of nothing but a collection of particles. Assuming that we are tracking one object (i.e.&nbsp;it is unimodal) we can compute the mean of the estimate as the sum of the weighted values of the particles.</p>
<p><span class="math display">\[\displaystyle \mu = \frac{1}{N}\sum_{i=1}^N w^ix^i\]</span></p>
<p>Here I adopt the notation <span class="math inline">\(x^i\)</span> to indicate the <span class="math inline">\(\mathtt{i}^{th}\)</span> particle. A superscript is used because we often need to use subscripts to denote time steps, yielding the unwieldy <span class="math inline">\(x^i_{k+1}\)</span> for the <span class="math inline">\(\mathtt{k+1}^{th}\)</span> time step for example.</p>
<p>This function computes both the mean and variance of the particles:</p>
<div id="cell-32" class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> estimate(particles, weights):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""returns mean and variance of the weighted particles"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    pos <span class="op">=</span> particles[:, <span class="dv">0</span>:<span class="dv">2</span>]</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    mean <span class="op">=</span> np.average(pos, weights<span class="op">=</span>weights, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    var  <span class="op">=</span> np.average((pos <span class="op">-</span> mean)<span class="op">**</span><span class="dv">2</span>, weights<span class="op">=</span>weights, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mean, var</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we create a uniform distribution of points in a 1x1 square with equal weights we get a mean position very near the center of the square at (0.5, 0.5) and a small variance.</p>
<div id="cell-34" class="cell" data-outputid="96ccdfc0-ffb9-473d-a13c-bf16d95a8543">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>particles <span class="op">=</span> create_uniform_particles((<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">0</span>,<span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">5</span>), <span class="dv">1000</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> np.array([<span class="fl">.25</span>]<span class="op">*</span><span class="dv">1000</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>estimate(particles, weights)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>(array([0.494, 0.514]), array([0.083, 0.085]))</code></pre>
</div>
</div>
</section>
<section id="particle-resampling" class="level3">
<h3 class="anchored" data-anchor-id="particle-resampling">Particle Resampling</h3>
<p>The SIS algorithm suffers from the <em>degeneracy problem</em>. It starts with uniformly distributed particles with equal weights. There may only be a handful of particles near the robot. As the algorithm runs any particle that does not match the measurements will acquire an extremely low weight. Only the particles which are near the robot will have an appreciable weight. We could have 5,000 particles with only 3 contributing meaningfully to the state estimate! We say the filter has <em>degenerated</em>.This problem is usually solved by some form of <em>resampling</em> of the particles.</p>
<p>Particles with very small weights do not meaningfully describe the probability distribution of the robot. The resampling algorithm discards particles with very low probability and replaces them with new particles with higher probability. It does that by duplicating particles with relatively high probability. The duplicates are slightly dispersed by the noise added in the predict step. This results in a set of points in which a large majority of the particles accurately represent the probability distribution.</p>
<p>There are many resampling algorithms. For now let’s look at one of the simplest, <em>simple random resampling</em>, also called <em>multinomial resampling</em>. It samples from the current particle set <span class="math inline">\(N\)</span> times, making a new set of particles from the sample. The probability of selecting any given particle should be proportional to its weight.</p>
<p>We accomplish this with NumPy’s <code>cumsum</code> function. <code>cumsum</code> computes the cumulative sum of an array. That is, element one is the sum of elements zero and one, element two is the sum of elements zero, one and two, etc. Then we generate random numbers in the range of 0.0 to 1.0 and do a binary search to find the weight that most closely matches that number:</p>
<div id="cell-36" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_resample(particles, weights):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="bu">len</span>(particles)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    cumulative_sum <span class="op">=</span> np.cumsum(weights)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    cumulative_sum[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="fl">1.</span> <span class="co"># avoid round-off error</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    indexes <span class="op">=</span> np.searchsorted(cumulative_sum, random(N))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># resample according to indexes</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    particles[:] <span class="op">=</span> particles[indexes]</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    weights.fill(<span class="fl">1.0</span> <span class="op">/</span> N)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We don’t resample at every epoch. For example, if you received no new measurements you have not received any information from which the resample can benefit. We can determine when to resample by using something called the <em>effective N</em>, which approximately measures the number of particles which meaningfully contribute to the probability distribution. The equation for this is</p>
<p><span class="math display">\[\hat{N}_\text{eff} = \frac{1}{\sum w^2}\]</span></p>
<p>and we can implement this in Python with</p>
<div id="cell-38" class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> neff(weights):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.</span> <span class="op">/</span> np.<span class="bu">sum</span>(np.square(weights))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If <span class="math inline">\(\hat{N}_\text{eff}\)</span> falls below some threshold it is time to resample. A useful starting point is <span class="math inline">\(N/2\)</span>, but this varies by problem. It is also possible for <span class="math inline">\(\hat{N}_\text{eff} = N\)</span>, which means the particle set has collapsed to one point (each has equal weight). It may not be theoretically pure, but if that happens I create a new distribution of particles in the hopes of generating particles with more diversity. If this happens to you often, you may need to increase the number of particles, or otherwise adjust your filter. We will talk more of this later.</p>
</section>
</section>
<section id="sir-filter---a-complete-example" class="level2">
<h2 class="anchored" data-anchor-id="sir-filter---a-complete-example">SIR Filter - A Complete Example</h2>
<p>There is more to learn, but we know enough to implement a full particle filter. We will implement the <em>Sampling Importance Resampling filter</em>, or SIR.</p>
<p>I need to introduce a more sophisticated resampling method than I gave above. FilterPy provides several resampling methods. I will describe them later. They take an array of weights and returns indexes to the particles that have been chosen for the resampling. We just need to write a function that performs the resampling from these indexes:</p>
<div id="cell-41" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> resample_from_index(particles, weights, indexes):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    particles[:] <span class="op">=</span> particles[indexes]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    weights.resize(<span class="bu">len</span>(particles))</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    weights.fill (<span class="fl">1.0</span> <span class="op">/</span> <span class="bu">len</span>(weights))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To implement the filter we need to create the particles and the landmarks. We then execute a loop, successively calling <code>predict</code>, <code>update</code>, resampling, and then computing the new state estimate with <code>estimate</code>.</p>
<div id="cell-43" class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> filterpy.monte_carlo <span class="im">import</span> systematic_resample</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.linalg <span class="im">import</span> norm</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> randn</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_pf1(N, iters<span class="op">=</span><span class="dv">18</span>, sensor_std_err<span class="op">=</span><span class="fl">.1</span>,</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>            do_plot<span class="op">=</span><span class="va">True</span>, plot_particles<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>            xlim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">20</span>), ylim<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">20</span>),</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>            initial_x<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    landmarks <span class="op">=</span> np.array([[<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">5</span>, <span class="dv">10</span>], [<span class="dv">12</span>,<span class="dv">14</span>], [<span class="dv">18</span>,<span class="dv">21</span>]])</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    NL <span class="op">=</span> <span class="bu">len</span>(landmarks)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    plt.figure()</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># create particles and weights</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> initial_x <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        particles <span class="op">=</span> create_gaussian_particles(</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>            mean<span class="op">=</span>initial_x, std<span class="op">=</span>(<span class="dv">5</span>, <span class="dv">5</span>, np.pi<span class="op">/</span><span class="dv">4</span>), N<span class="op">=</span>N)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>        particles <span class="op">=</span> create_uniform_particles((<span class="dv">0</span>,<span class="dv">20</span>), (<span class="dv">0</span>,<span class="dv">20</span>), (<span class="dv">0</span>, <span class="fl">6.28</span>), N)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> np.ones(N) <span class="op">/</span> N</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> plot_particles:</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> <span class="fl">.20</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> N <span class="op">&gt;</span> <span class="dv">5000</span>:</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>            alpha <span class="op">*=</span> np.sqrt(<span class="dv">5000</span>)<span class="op">/</span>np.sqrt(N)</span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>        plt.scatter(particles[:, <span class="dv">0</span>], particles[:, <span class="dv">1</span>],</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>                    alpha<span class="op">=</span>alpha, color<span class="op">=</span><span class="st">'g'</span>)</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> []</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>    robot_pos <span class="op">=</span> np.array([<span class="fl">0.</span>, <span class="fl">0.</span>])</span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(iters):</span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>        robot_pos <span class="op">+=</span> (<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>        <span class="co"># distance from robot to each landmark</span></span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        zs <span class="op">=</span> (norm(landmarks <span class="op">-</span> robot_pos, axis<span class="op">=</span><span class="dv">1</span>) <span class="op">+</span></span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>              (randn(NL) <span class="op">*</span> sensor_std_err))</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># move diagonally forward to (x+1, x+1)</span></span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a>        predict(particles, u<span class="op">=</span>(<span class="fl">0.00</span>, <span class="fl">1.414</span>), std<span class="op">=</span>(<span class="fl">.2</span>, <span class="fl">.05</span>))</span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a>        <span class="co"># incorporate measurements</span></span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>        update(particles, weights, z<span class="op">=</span>zs, R<span class="op">=</span>sensor_std_err,</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a>               landmarks<span class="op">=</span>landmarks)</span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>        <span class="co"># resample if too few effective particles</span></span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> neff(weights) <span class="op">&lt;</span> N<span class="op">/</span><span class="dv">2</span>:</span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a>            indexes <span class="op">=</span> systematic_resample(weights)</span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>            resample_from_index(particles, weights, indexes)</span>
<span id="cb24-50"><a href="#cb24-50" aria-hidden="true" tabindex="-1"></a>            <span class="cf">assert</span> np.allclose(weights, <span class="dv">1</span><span class="op">/</span>N)</span>
<span id="cb24-51"><a href="#cb24-51" aria-hidden="true" tabindex="-1"></a>        mu, var <span class="op">=</span> estimate(particles, weights)</span>
<span id="cb24-52"><a href="#cb24-52" aria-hidden="true" tabindex="-1"></a>        xs.append(mu)</span>
<span id="cb24-53"><a href="#cb24-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-54"><a href="#cb24-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> plot_particles:</span>
<span id="cb24-55"><a href="#cb24-55" aria-hidden="true" tabindex="-1"></a>            plt.scatter(particles[:, <span class="dv">0</span>], particles[:, <span class="dv">1</span>],</span>
<span id="cb24-56"><a href="#cb24-56" aria-hidden="true" tabindex="-1"></a>                        color<span class="op">=</span><span class="st">'k'</span>, marker<span class="op">=</span><span class="st">','</span>, s<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-57"><a href="#cb24-57" aria-hidden="true" tabindex="-1"></a>        p1 <span class="op">=</span> plt.scatter(robot_pos[<span class="dv">0</span>], robot_pos[<span class="dv">1</span>], marker<span class="op">=</span><span class="st">'+'</span>,</span>
<span id="cb24-58"><a href="#cb24-58" aria-hidden="true" tabindex="-1"></a>                         color<span class="op">=</span><span class="st">'k'</span>, s<span class="op">=</span><span class="dv">180</span>, lw<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb24-59"><a href="#cb24-59" aria-hidden="true" tabindex="-1"></a>        p2 <span class="op">=</span> plt.scatter(mu[<span class="dv">0</span>], mu[<span class="dv">1</span>], marker<span class="op">=</span><span class="st">'s'</span>, color<span class="op">=</span><span class="st">'r'</span>)</span>
<span id="cb24-60"><a href="#cb24-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-61"><a href="#cb24-61" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> np.array(xs)</span>
<span id="cb24-62"><a href="#cb24-62" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plt.plot(xs[:, 0], xs[:, 1])</span></span>
<span id="cb24-63"><a href="#cb24-63" aria-hidden="true" tabindex="-1"></a>    plt.legend([p1, p2], [<span class="st">'Actual'</span>, <span class="st">'PF'</span>], loc<span class="op">=</span><span class="dv">4</span>, numpoints<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-64"><a href="#cb24-64" aria-hidden="true" tabindex="-1"></a>    plt.xlim(<span class="op">*</span>xlim)</span>
<span id="cb24-65"><a href="#cb24-65" aria-hidden="true" tabindex="-1"></a>    plt.ylim(<span class="op">*</span>ylim)</span>
<span id="cb24-66"><a href="#cb24-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'final position error, variance:</span><span class="ch">\n\t</span><span class="st">'</span>, mu <span class="op">-</span> np.array([iters, iters]), var)</span>
<span id="cb24-67"><a href="#cb24-67" aria-hidden="true" tabindex="-1"></a>    plt.show()</span>
<span id="cb24-68"><a href="#cb24-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-69"><a href="#cb24-69" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy.random <span class="im">import</span> seed</span>
<span id="cb24-70"><a href="#cb24-70" aria-hidden="true" tabindex="-1"></a>seed(<span class="dv">2</span>)</span>
<span id="cb24-71"><a href="#cb24-71" aria-hidden="true" tabindex="-1"></a>run_pf1(N<span class="op">=</span><span class="dv">5000</span>, plot_particles<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Most of this code is devoted to initialization and plotting. The entirety of the particle filter processing consists of these lines:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># move diagonally forward to (x+1, x+1)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>predict(particles, u<span class="op">=</span>(<span class="fl">0.00</span>, <span class="fl">1.414</span>), std<span class="op">=</span>(<span class="fl">.2</span>, <span class="fl">.05</span>))</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a> <span class="co"># incorporate measurements</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>update(particles, weights, z<span class="op">=</span>zs, R<span class="op">=</span>sensor_std_err,</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>       landmarks<span class="op">=</span>landmarks)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>       </span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="co"># resample if too few effective particles</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> neff(weights) <span class="op">&lt;</span> N<span class="op">/</span><span class="dv">2</span>:</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    indexes <span class="op">=</span> systematic_resample(weights)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    resample_from_index(particles, weights, indexes)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>mu, var <span class="op">=</span> estimate(particles, weights)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first line predicts the position of the particles with the assumption that the robot is moving in a straight line (<code>u[0] == 0</code>) and moving 1 unit in both the x and y axis (<code>u[1]==1.414</code>). The standard deviation for the error in the turn is 0.2, and the standard deviation for the distance is 0.05. When this call returns the particles will all have been moved forward, but the weights are no longer correct as they have not been updated.</p>
<p>The next line incorporates the measurement into the filter. This does not alter the particle positions, it only alters the weights. If you recall the weight of the particle is computed as the probability that it matches the Gaussian of the sensor error model. The further the particle from the measured distance the less likely it is to be a good representation.</p>
<p>The final two lines example the effective particle count (<span class="math inline">\(\hat{N}_\text{eff})\)</span>. If it falls below <span class="math inline">\(N/2\)</span> we perform resampling to try to ensure our particles form a good representation of the actual probability distribution.</p>
<p>Now let’s look at this with all the particles plotted. Seeing this happen interactively is much more instructive, but this format still gives us useful information. I plotted the original random distribution of points in a very pale green and large circles to help distinguish them from the subsequent iterations where the particles are plotted with black pixels. The number of particles makes it hard to see the details, so I limited the number of iterations to 8 so we can zoom in and look more closely.</p>
<div id="cell-45" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>seed(<span class="dv">2</span>)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>run_pf1(N<span class="op">=</span><span class="dv">5000</span>, iters<span class="op">=</span><span class="dv">8</span>, plot_particles<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        xlim<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">8</span>), ylim<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">8</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>From the plot it looks like there are only a few particles at the first two robot positions. This is not true; there are 5,000 particles, but due to resampling most are duplicates of each other. The reason for this is the Gaussian for the sensor is very narrow. This is called <em>sample impoverishment</em> and can lead to filter divergence. I’ll address this in detail below. For now, looking at the second step at x=2 we can see that the particles have dispersed a bit. This dispersion is due to the motion model noise. All particles are projected forward according to the control input <code>u</code>, but noise is added to each particle proportional to the error in the control mechanism in the robot. By the third step the particles have dispersed enough to make a convincing cloud of particles around the robot.</p>
<p>The shape of the particle cloud is an ellipse. This is not a coincidence. The sensors and robot control are both modeled as Gaussian, so the probability distribution of the system is also a Gaussian. The particle filter is a sampling of the probability distribution, so the cloud should be an ellipse.</p>
<p>It is important to recognize that the particle filter algorithm <em>does not require</em> the sensors or system to be Gaussian or linear. Because we represent the probability distribution with a cloud of particles we can handle any probability distribution and strongly nonlinear problems. There can be discontinuities and hard limits in the probability model.</p>
<section id="effect-of-sensor-errors-on-the-filter" class="level3">
<h3 class="anchored" data-anchor-id="effect-of-sensor-errors-on-the-filter">Effect of Sensor Errors on the Filter</h3>
<p>The first few iterations of the filter resulted in many duplicate particles. This happens because the model for the sensors is Gaussian, and we gave it a small standard deviation of <span class="math inline">\(\sigma=0.1\)</span>. This is counterintuitive at first. The Kalman filter performs better when the noise is smaller, yet the particle filter can perform worse.</p>
<p>We can reason about why this is true. If <span class="math inline">\(\sigma=0.1\)</span>, the robot is at (1, 1) and a particle is at (2, 2) the particle is 14 standard deviations away from the robot. This gives it a near zero probability. It contributes nothing to the estimate of the mean, and it is extremely unlikely to survive after the resampling. If <span class="math inline">\(\sigma=1.4\)</span> then the particle is only <span class="math inline">\(1\sigma\)</span> away and thus it will contribute to the estimate of the mean. During resampling it is likely to be copied one or more times.</p>
<p>This is <em>very important</em> to understand - a very accurate sensor can lead to poor performance of the filter because few of the particles will be a good sample of the probability distribution. There are a few fixes available to us. First, we can artificially increase the sensor noise standard deviation so the particle filter will accept more points as matching the robots probability distribution. This is non-optimal because some of those points will be a poor match. The real problem is that there aren’t enough points being generated such that enough are near the robot. Increasing <code>N</code> usually fixes this problem. This decision is not cost free as increasing the number of particles significantly increase the computation time. Still, let’s look at the result of using 100,000 particles.</p>
<div id="cell-48" class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>seed(<span class="dv">2</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>run_pf1(N<span class="op">=</span><span class="dv">100000</span>, iters<span class="op">=</span><span class="dv">8</span>, plot_particles<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>        xlim<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">8</span>), ylim<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">8</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="fill-in-observe-results-and-write-conclusions" class="level2">
<h2 class="anchored" data-anchor-id="fill-in-observe-results-and-write-conclusions">FILL IN: Observe results and write conclusions</h2>
<p>Another approach is to be smarter about generating the initial particle cloud. Suppose we guess that the robot is near (0, 0). This is not exact, as the simulation actually places the robot at (1, 1), but it is close. If we create a normally distributed cloud near (0, 0) there is a much greater chance of the particles matching the robot’s position.</p>
<p><code>run_pf1()</code> has an optional parameter <code>initial_x</code>. Use this to specify the initial position guess for the robot. The code then uses <code>create_gaussian_particles(mean, std, N)</code> to create particles distributed normally around the initial guess. We will use this in the next section.</p>
<section id="filter-degeneracy-from-inadequate-samples" class="level3">
<h3 class="anchored" data-anchor-id="filter-degeneracy-from-inadequate-samples">Filter Degeneracy From Inadequate Samples</h3>
<p>Please rerun the filter but with 5000 samples instead of 100000.</p>
<div id="cell-52" class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># FILL IN CODE: RERUN WITH 5000 samples.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="fill-in-observe-results-and-write-conclusions-1" class="level2">
<h2 class="anchored" data-anchor-id="fill-in-observe-results-and-write-conclusions-1">FILL IN: Observe results and write conclusions</h2>
<p>Let’s make use of the <code>create_gaussian_particles()</code> method to try to generate more points near the robot. We can do this by using the <code>initial_x</code> parameter to specify a location to create the particles.</p>
<div id="cell-55" class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>seed(<span class="dv">6</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>run_pf1(N<span class="op">=</span><span class="dv">5000</span>, plot_particles<span class="op">=</span><span class="va">True</span>, initial_x<span class="op">=</span>(<span class="dv">1</span>,<span class="dv">1</span>, np.pi<span class="op">/</span><span class="dv">4</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="fill-in-observe-results-and-write-conclusions-2" class="level2">
<h2 class="anchored" data-anchor-id="fill-in-observe-results-and-write-conclusions-2">FILL IN: Observe results and write conclusions</h2>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>This chapter only touches the surface of what is a vast topic. My goal was not to teach you the field, but to expose you to practical Bayesian Monte Carlo techniques for filtering.</p>
<p>Particle filters are a type of <em>ensemble</em> filtering. Kalman filters represents state with a Gaussian. Measurements are applied to the Gaussian using Bayes Theorem, and the prediction is done using state-space methods. These techniques are applied to the Gaussian - the probability distribution.</p>
<p>In contrast, ensemble techniques represent a probability distribution using a discrete collection of points and associated probabilities. Measurements are applied to these points, not the Gaussian distribution. Likewise, the system model is applied to the points, not a Gaussian. We then compute the statistical properties of the resulting ensemble of points.</p>
<p>These choices have many trade-offs. The Kalman filter is very efficient, and is an optimal estimator if the assumptions of linearity and Gaussian noise are true. If the problem is nonlinear than we must linearize the problem. If the problem is multimodal (more than one object being tracked) then the Kalman filter cannot represent it. The Kalman filter requires that you know the state model. If you do not know how your system behaves the performance is poor.</p>
<p>In contrast, particle filters work with any arbitrary, non-analytic probability distribution. The ensemble of particles, if large enough, form an accurate approximation of the distribution. It performs wonderfully even in the presence of severe nonlinearities. Importance sampling allows us to compute probabilities even if we do not know the underlying probability distribution. Monte Carlo techniques replace the analytic integrals required by the other filters.</p>
<p>This power comes with a cost. The most obvious costs are the high computational and memory burdens the filter places on the computer. Less obvious is the fact that they are fickle. You have to be careful to avoid particle degeneracy and divergence. It can be very difficult to prove the correctness of your filter. If you are working with multimodal distributions you have further work to cluster the particles to determine the paths of the multiple objects. This can be very difficult when the objects are close to each other.</p>
<p>There are many different classes of particle filter; I only described the naive SIS algorithm, and followed that with a SIR algorithm that performs well. There are many classes of filters, and many examples of filters in each class. It would take a small book to describe them all.</p>
<p>When you read the literature on particle filters you will find that it is strewn with integrals. We perform computations on probability distributions using integrals, so using integrals gives the authors a powerful and compact notation. You must recognize that when you reduce these equations to code you will be representing the distributions with particles, and integrations are replaced with sums over the particles. If you keep in mind the core ideas in this chapter the material shouldn’t be daunting.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>[1] <em>Importance Sampling</em>, Wikipedia. https://en.wikipedia.org/wiki/Importance_sampling</p>


</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>