<!DOCTYPE html>
<html lang="en"><head>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.4.549">

  <meta name="dcterms.date" content="2024-02-14">
  <title>Digital Twins for Physical Systems - Bayesian Data Assimilation</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      { color: #003b4f; background-color: #f1f3f5; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #003b4f; } /* Normal */
    code span.al { color: #ad0000; } /* Alert */
    code span.an { color: #5e5e5e; } /* Annotation */
    code span.at { color: #657422; } /* Attribute */
    code span.bn { color: #ad0000; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #003b4f; } /* ControlFlow */
    code span.ch { color: #20794d; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #5e5e5e; } /* Comment */
    code span.cv { color: #5e5e5e; font-style: italic; } /* CommentVar */
    code span.do { color: #5e5e5e; font-style: italic; } /* Documentation */
    code span.dt { color: #ad0000; } /* DataType */
    code span.dv { color: #ad0000; } /* DecVal */
    code span.er { color: #ad0000; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #ad0000; } /* Float */
    code span.fu { color: #4758ab; } /* Function */
    code span.im { color: #00769e; } /* Import */
    code span.in { color: #5e5e5e; } /* Information */
    code span.kw { color: #003b4f; } /* Keyword */
    code span.op { color: #5e5e5e; } /* Operator */
    code span.ot { color: #003b4f; } /* Other */
    code span.pp { color: #ad0000; } /* Preprocessor */
    code span.sc { color: #5e5e5e; } /* SpecialChar */
    code span.ss { color: #20794d; } /* SpecialString */
    code span.st { color: #20794d; } /* String */
    code span.va { color: #111111; } /* Variable */
    code span.vs { color: #20794d; } /* VerbatimString */
    code span.wa { color: #5e5e5e; font-style: italic; } /* Warning */
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="../../site_libs/revealjs/dist/theme/quarto.css">
  <link href="../../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    padding-bottom: 0.5rem;
    margin-bottom: 0;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" data-background-image="../images/3DVAR.png" data-background-opacity="0.5" data-background-size="contain" class="quarto-title-block center">
  <h1 class="title">Bayesian Data Assimilation</h1>
  <p class="subtitle">Data Assimilation</p>

<div class="quarto-title-authors">
</div>

  <p class="date">2024-02-14</p>
</section>
<section id="bayesian-filters" class="slide level2 center">
<h2>Bayesian filters</h2>
<p>We begin by defining a probabilistic state-space, or nonlinear <span style="color: magenta">filtering model</span>, of the form <span id="eq-filter"><span class="math display">\[\begin{aligned}
    \mathbf{x}_{k} &amp; \sim p(\mathbf{x}_{k}\mid\mathbf{x}_{k-1}),\label{eq:filter1}\\
    \mathbf{y}_{k} &amp; \sim p(\mathbf{y}_{k}\mid\mathbf{x}_{k}),\quad k=0,1,2,\ldots,\label{eq:filter2}
    \end{aligned} \tag{1}\]</span></span> where</p>
<ul>
<li><p><span class="math inline">\(\mathbf{x}_{k}\in\mathbb{R}^{n}\)</span> is the <span style="color: magenta">state vector</span> at time <span class="math inline">\(k,\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{y}_{k}\in\mathbb{R}^{m}\)</span> is the <span style="color: magenta">observation vector</span> at time <span class="math inline">\(k,\)</span></p></li>
<li><p>the <span style="color: magenta">conditional probability, <span class="math inline">\(p(\mathbf{x}_{k}\mid\mathbf{x}_{k-1}),\)</span></span> represents the stochastic <span style="color: magenta">dynamics model</span>, and can be a probability density or a discrete probability function, or a mixture of both,</p></li>
<li><p>the <span style="color: magenta">conditional probability, <span class="math inline">\(p(\mathbf{y}_{k}\mid\mathbf{x}_{k}),\)</span></span> represents the <span style="color: magenta">measurement model</span> and its inherent <span style="color: magenta">noise</span>.</p></li>
</ul>
</section>
<section id="section" class="slide level2 center">
<h2></h2>
<p>In addition, we assume that the model is <span style="color: magenta">Markovian</span>, such that <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{x}_{1:k-1},\mathbf{y}_{1:k-1})=p(\mathbf{x}_{k}\mid\mathbf{x}_{k-1}),\]</span> and that the <span style="color: magenta">observations</span> are conditionally <span style="color: magenta">independent</span> of state and measurement histories, <span class="math display">\[p(\mathbf{y}_{k}\mid\mathbf{x}_{1:k},\mathbf{y}_{1:k-1})=p(\mathbf{y}_{k}\mid\mathbf{x}_{k}).\]</span></p>
</section>
<section id="example-of-gaussian-random-walk" class="slide level2 center">
<h2>Example of Gaussian Random Walk</h2>
<p>To fix ideas and notation, we begin with a very <span style="color: magenta">simple, scalar case</span>, the Gaussian random walk model. This model can then easily be generalized.</p>
<p>Consider the scalar system <span id="eq-GRW"><span class="math display">\[\begin{aligned}
    x_{k} &amp; =x_{k-1}+w_{k-1},\quad w_{k-1}\sim\mathcal{N}(0,Q),\label{eq:GRW-x}\\
    y_{k} &amp; =x_{k}+v_{k},\quad v_{k}\sim\mathcal{N}(0,R),\label{eq:GRW-y}
    \end{aligned} \tag{2}\]</span></span> where <span class="math inline">\(x_{k}\)</span> is the (hidden) <span style="color: magenta">state</span> and <span class="math inline">\(y_{k}\)</span> is the (known) <span style="color: magenta">measurement</span>.</p>
<p>Noting that <span class="math inline">\(x_{k}-x_{k-1}=w_{k-1}\)</span> and that <span class="math inline">\(y_{k}-x_{k}=v_{k},\)</span> we can immediately rewrite this system in terms of the <span style="color: magenta">conditional probability densities</span>, <span class="math display">\[\begin{aligned}
    p(x_{k}\mid x_{k-1}) &amp; =\mathcal{N}\left(x_{k}\mid x_{k-1},Q\right)\\
     &amp; =\dfrac{1}{\sqrt{2\pi Q}}\exp\left[-\frac{1}{2Q}\left(x_{k}-x_{k-1}\right)^{2}\right]
    \end{aligned}\]</span> and</p>
</section>
<section id="section-1" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[\begin{aligned}
    p(y_{k}\mid x_{k}) &amp; =\mathcal{N}\left(y_{k}\mid x_{k},R\right)\\
     &amp; =\dfrac{1}{\sqrt{2\pi R}}\exp\left[-\frac{1}{2R}\left(y_{k}-x_{k}\right)^{2}\right].
    \end{aligned}\]</span></p>
<p>A realization of the model is shown in <a href="#/fig-GRW" class="quarto-xref">Figure&nbsp;1</a>.</p>

<img data-src="../images/GRW.png" style="width:50.0%" class="r-stretch quarto-figure-center"><p class="caption">
Figure&nbsp;1: Gaussian random walk state space model equations <a href="#/example-of-gaussian-random-walk" class="quarto-xref">2</a>. State, <span class="math inline">\(x_k\)</span> is solid blue curve, measurements, <span class="math inline">\(y_k\)</span>, are red circles. Fixed values of noise variance are <span class="math inline">\(Q=1\)</span> and <span class="math inline">\(R=1\)</span>
</p></section>
<section id="code" class="slide level2 center">
<h2>Code</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource {matlab} number-lines code-with-copy"><code class="sourceCode"><span id="cb1-1"><a></a>%&nbsp;Simulate&nbsp;a&nbsp;Gaussian&nbsp;random&nbsp;walk.</span>
<span id="cb1-2"><a></a>%&nbsp;initialize</span>
<span id="cb1-3"><a></a>randn('state',123)</span>
<span id="cb1-4"><a></a>R=1;&nbsp;Q=1;&nbsp;K=100;</span>
<span id="cb1-5"><a></a>%&nbsp;simulate</span>
<span id="cb1-6"><a></a>X_init&nbsp;=&nbsp;sqrt(Q)\*randn(K,1);</span>
<span id="cb1-7"><a></a>X&nbsp;=&nbsp;cumsum(X_init);</span>
<span id="cb1-8"><a></a>W&nbsp;=&nbsp;sqrt(R)\*randn(K,1);</span>
<span id="cb1-9"><a></a>Y&nbsp;=&nbsp;X&nbsp;+&nbsp;W;</span>
<span id="cb1-10"><a></a>%&nbsp;plot</span>
<span id="cb1-11"><a></a>plot(1:K,X,1:K,Y(1:K,1),'ro')</span>
<span id="cb1-12"><a></a>xlabel('k'),&nbsp;ylabel('x_k')</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="nonlinear-filter-model" class="slide level2 center">
<h2>Nonlinear Filter Model</h2>
<p>Using the nonlinear filtering model <a href="#/bayesian-filters" class="quarto-xref">1</a> and the Markov property, we can express the <span style="color: magenta">joint prior</span> of the states, <span class="math inline">\(\mathbf{x}_{0:T}=\{\mathbf{x}_{0},\ldots,\mathbf{x}_{T}\},\)</span> and the <span style="color: magenta">joint likelihood</span> of the measurements, <span class="math inline">\(\mathbf{y}_{1:T}=\{\mathbf{y}_{1},\ldots,\mathbf{y}_{T}\},\)</span> as the products <span class="math display">\[p(\mathbf{x}_{0:T})=p(\mathbf{x}_{0})\prod_{k=1}^{T}p(\mathbf{x}_{k}\mid\mathbf{x}_{k-1})\]</span> and <span class="math display">\[p(\mathbf{y}_{1:T}\mid\mathbf{x}_{0:T})=\prod_{k=1}^{T}p(\mathbf{y}_{k}\mid\mathbf{x}_{k})\]</span> respectively.</p>
</section>
<section id="section-2" class="slide level2 center">
<h2></h2>
<p>Then, applying <span style="color: magenta">Bayes’ law</span>, we can compute the complete <span style="color: magenta">posterior distribution</span> of the states as <span class="math display">\[p(\mathbf{x}_{0:T}\mid\mathbf{y}_{1:T})=\frac{p(\mathbf{y}_{1:T}\mid\mathbf{x}_{0:T})p(\mathbf{x}_{0:T})}{p(\mathbf{y}_{1:T})}.\label{eq:Bayes-post-state-eq}\]</span></p>
<p>But this type of <span style="color: magenta">complete characterization</span> is not feasible to compute in real-time, or near real-time, since the number of computations per time-step increases as measurements arrive.</p>
<p>What we need is a <span style="color: magenta">fixed number of computations per time-step</span>.</p>
<ul>
<li><p>This can be achieved by a <span style="color: magenta">recursive estimation</span> that, step by step, produces the filtering distribution defined above.</p></li>
<li><p>In this light, we can now define the general <span style="color: magenta">Bayesian filtering problem</span>, of which Kalman filters will be a special case.</p></li>
</ul>
</section>
<section id="section-3" class="slide level2 center">
<h2></h2>
<div id="def-BayesFilter" class="theorem definition">
<p><span class="theorem-title"><strong>Definition 1</strong></span> <em><span style="color: magenta">Bayesian filtering</span> is the recursive computation of the marginal posterior distribution, <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k})\]</span> known as the filtering distribution, of the state <span class="math inline">\(\mathbf{x}_{k}\)</span> at each time step <span class="math inline">\(k,\)</span> given the measurements up to time <span class="math inline">\(k.\)</span></em></p>
</div>
<p>Now, based on Bayes’ rule, we can formulate the <span style="color: magenta">Bayesian filtering theorem</span> <span class="citation" data-cites="sarkka2013">(<a href="#/references" role="doc-biblioref" onclick="">Särkkä and Svensson 2023</a>)</span> .</p>
<div id="thm-BayesFilter" class="theorem">
<p><span class="theorem-title"><strong>Theorem 1</strong></span> (Bayesian Filter). <em>The recursive equations, known as the <span style="color: magenta">Bayesian filter</span>, for computing the filtering distribution <span class="math inline">\(p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k})\)</span> and the predicted distribution <span class="math inline">\(p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k-1})\)</span> at the time step <span class="math inline">\(k,\)</span> are given by the three-stage process:</em></p>
<p><em><strong>Initialization</strong>: Define the prior distribution <span class="math inline">\(p(\mathbf{x}_{0}).\)</span></em></p>
<p><em><strong>Prediction:</strong> Compute the predictive distribution <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k-1})=\int p(\mathbf{x}_{k}\mid\mathbf{x}_{k-1})p(\mathbf{x}_{k-1}\mid\mathbf{y}_{1:k-1})\,\mathrm{d}\mathbf{x}_{k-1}.\]</span></em></p>
</div>
</section>
<section id="section-4" class="slide level2 center">
<h2></h2>
<p><strong>Correction</strong>: <em>Compute the posterior distribution by Bayes’ rule,</em></p>
<div class="r-fit-text">
<p><span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k})=\frac{p(\mathbf{y}_{k}\mid\mathbf{x}_{k})p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k-1})}{\int p(\mathbf{y}_{k}\mid\mathbf{x}_{k})p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k-1})}\,\mathrm{d}\mathbf{x}_{k}.\]</span></p>
<p>Now, if we assume that the <span style="color: magenta">dynamic and measurement models are linear</span>, with i.i.d. <span style="color: magenta">Gaussian noise</span>, then we obtain the closed-form solution for the <span style="color: magenta">Kalman filter</span>, already derived in the Basic Course. We recall the linear, Gaussian state-space model, <span id="eq-kf"><span class="math display">\[\begin{aligned}
\mathbf{x}_{k} &amp; =\mathbf{M}_{k-1}\mathbf{x}_{k-1}+\mathbf{w}_{k-1},\label{eq:kf-1}\\
\mathbf{y}_{k} &amp; =\mathbf{H}_{k}\mathbf{x}_{k}+\mathbf{v}_{k},\label{eq:kf-2}
\end{aligned} \tag{3}\]</span></span> for the Kalman filter, where</p>
<ul>
<li><p><span class="math inline">\(\mathbf{x}_{k}\in\mathbb{R}^{n}\)</span> is the state,</p></li>
<li><p><span class="math inline">\(\mathbf{y}_{k}\in\mathbb{R}^{m}\)</span> is the measurement,</p></li>
<li><p><span class="math inline">\(\mathbf{w}_{k-1}\sim\mathcal{N}(0,\mathbf{Q}_{k-1})\)</span> is the process noise,</p></li>
<li><p><span class="math inline">\(\mathbf{v}_{k}\sim\mathcal{N}(0,\mathbf{R}_{k})\)</span> is the measurement noise,</p></li>
<li><p><span class="math inline">\(\mathbf{x}_{0}\sim\mathcal{N}(\mathbf{m}_{0},\mathbf{P}_{0})\)</span> is the Gaussian distributed initial state, with mean <span class="math inline">\(\mathbf{m}_{0}\)</span> and covariance <span class="math inline">\(\mathbf{P}_{0},\)</span></p></li>
<li><p><span class="math inline">\(\mathbf{M}_{k-1}\)</span> is the time-dependent transition matrix of the dynamic model at time <span class="math inline">\(k-1,\)</span> and</p></li>
<li><p><span class="math inline">\(\mathbf{H}_{k}\)</span> is the time-dependent measurement model matrix.</p></li>
</ul>
</div>
</section>
<section id="section-5" class="slide level2 center">
<h2></h2>
<p>This model can be very elegantly rewritten in terms of <span style="color: magenta">conditional probabilities</span> as <span class="math display">\[\begin{aligned}
p(\mathbf{x}_{k}\mid\mathbf{x}_{k-1}) &amp; =\mathcal{N}\left(\mathbf{x}_{k}\mid\mathbf{M}_{k-1}\mathbf{x}_{k-1},\mathbf{Q}_{k-1}\right),\\
p(\mathbf{y}_{k}\mid\mathbf{x}_{k}) &amp; =\mathcal{N}\left(\mathbf{y}_{k}\mid\mathbf{H}_{k}\mathbf{x}_{k},\mathbf{R}_{k}\right).
\end{aligned}\]</span></p>
<div id="thm-KF" class="theorem">
<p><span class="theorem-title"><strong>Theorem 2</strong></span> (Kalman Filter). <em>The Bayesian filtering equations for the linear, Gaussian model <a href="#/section-4" class="quarto-xref">Equation&nbsp;3</a> can be explicitly computed and the resulting conditional probability distributions are Gaussian. The prediction distribution is</em> <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k-1})=\mathcal{N}\left(\mathbf{x}_{k}\mid\hat{\mathbf{m}}_{k},\hat{\mathbf{P}}_{k}\right),\]</span> <em>the filtering distribution is</em> <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k})=\mathcal{N}\left(\mathbf{x}_{k}\mid\mathbf{m}_{k},\mathbf{P}_{k}\right)\]</span> <em>and the smoothing distribution is</em> <span class="math display">\[p(\mathbf{y}_{k}\mid\mathbf{y}_{1:k-1})=\mathcal{N}\left(\mathbf{y}_{k}\mid\mathbf{H}_{k}\mathbf{\hat{m}}_{k},\mathbf{S}_{k}\right).\]</span></p>
</div>
</section>
<section id="section-6" class="slide level2 center">
<h2></h2>
<p><em>The parameters of these distributions can be computed by the three-stage <span style="color: magenta">Kalman filter</span> loop:</em></p>
<p><strong>Initialization</strong>: <em>Define the prior mean <span class="math inline">\(\mathbf{m}_{0}\)</span> and prior covariance <span class="math inline">\(\mathbf{P}_{0}.\)</span></em></p>
<p><strong>Prediction</strong>: <em>Compute the predictive distribution mean and covariance,</em> <span class="math display">\[\begin{aligned}
\mathbf{\hat{m}}_{k} &amp; =\mathbf{M}_{k-1}\mathbf{m}_{k-1},\\
\hat{\mathbf{P}}_{k} &amp; =\mathbf{M}_{k-1}\mathbf{P}_{k-1}\mathbf{M}_{k-1}^{\mathrm{T}}+\mathbf{Q}_{k-1}.
\end{aligned}\]</span></p>
<p><strong>Correction</strong>: <em>Compute the filtering distribution mean and covariance by first defining</em> <span class="math display">\[\begin{aligned}
\mathbf{d}_{k} &amp; =\mathbf{y}_{k}-\mathbf{H}_{k}\mathbf{\hat{m}}_{k},\quad\textrm{the innovation},\\
\mathbf{S}_{k} &amp; =\mathbf{H}_{k}\hat{\mathbf{P}}_{k}\mathbf{H}_{k}^{\mathrm{T}}+\mathbf{R}_{k},\quad\textrm{the measurement covariance},\\
\mathbf{K}_{k} &amp; =\hat{\mathbf{P}}_{k}\mathbf{H}_{k}^{\mathrm{T}}\mathbf{S}_{k}^{-1},\quad\textrm{the Kalman gain,}
\end{aligned}\]</span></p>
<p><em>then finally updating the filter mean and covariance,</em></p>
</section>
<section id="section-7" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[\begin{aligned}
\mathbf{m}_{k} &amp; =\mathbf{\hat{m}}_{k}+\mathbf{K}_{k}\mathbf{d}_{k},\\
\mathbf{P}_{k} &amp; =\hat{\mathbf{P}}_{k}-\mathbf{K}_{k}\mathbf{S}_{k}\mathbf{K}_{k}^{\mathrm{T}}.
\end{aligned}\]</span></p>
<div class="proof">
<p><span class="proof-title"><em>Proof</em>. </span>The proof see <span class="citation" data-cites="sarkka2013">Särkkä and Svensson (<a href="#/references" role="doc-biblioref" onclick="">2023</a>)</span> is a direct application of classical results for the joint, marginal, and conditional distributions of two Gaussian random variables, <span class="math inline">\(\mathbf{x}_{k}\in\mathbb{R}^{n}\)</span> and <span class="math inline">\(\mathbf{y}_{k}\in\mathbb{R}^{m}.\)</span>&nbsp;</p>
</div>
</section>
<section id="kf-for-gaussian-random-walk" class="slide level2 center">
<h2>KF for Gaussian Random Walk</h2>
<p>We now return to the <span style="color: magenta">Gaussian random walk</span> model seen above in the Example, and formulate a <span style="color: magenta">Kalman filter</span> for estimating its state from noisy measurements.</p>
<div id="exm-KFRW" class="theorem example">
<p><span class="theorem-title"><strong>Example 1</strong></span> <span style="color: blue">Kalman Filter for Gaussian Random Walk</span>. Suppose that we have measurements of the scalar <span class="math inline">\(y_{k}\)</span> from the Gaussian random walk model <span id="eq-GRW-2"><span class="math display">\[\begin{aligned}
x_{k} &amp; =x_{k-1}+w_{k-1},\quad w_{k-1}\sim\mathcal{N}(0,Q),\label{eq:GRW-x2}\\
y_{k} &amp; =x_{k}+v_{k},\quad v_{k}\sim\mathcal{N}(0,R).\label{eq:GRW-y2}
\end{aligned} \tag{4}\]</span></span> This very basic system is found in many applications where</p>
<ul>
<li><p><span class="math inline">\(x_{k}\)</span> represents a slowly varying quantity that we measure directly.</p></li>
<li><p>process noise, <span class="math inline">\(w_{k},\)</span> takes into account fluctuations in the state <span class="math inline">\(x_{k}.\)</span></p></li>
<li><p>measurement noise, <span class="math inline">\(v_{k},\)</span> accounts for measurement instrument errors.</p></li>
</ul>
</div>
<p>We want to estimate the state <span class="math inline">\(x_{k}\)</span> over time, taking into account the measurements <span class="math inline">\(y_{k}.\)</span> That is, we would like to compute the <span style="color: magenta">filtering density</span>,</p>
</section>
<section id="section-8" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[p({x}_{k}\mid{y}_{1:k})=\mathcal{N}\left({x}_{k}\mid{m}_{k},{P}_{k}\right).\]</span> We proceed by simply writing down the three stages of the Kalman filter, noting that <span class="math inline">\(M_{k}=1\)</span> and <span class="math inline">\(H_{k}=1\)</span> for this model. We obtain:</p>
<p><strong>Initialization</strong>: Define the prior mean <span class="math inline">\({m}_{0}\)</span> and prior covariance <span class="math inline">\({P}_{0}.\)</span></p>
<p><strong>Prediction:</strong> <span class="math display">\[\begin{aligned}
{\hat{m}}_{k} &amp; ={m}_{k-1},\\
\hat{{P}}_{k} &amp; ={P}_{k-1}+{Q}.
\end{aligned}\]</span></p>
<p><strong>Correction</strong>: Define <span class="math display">\[\begin{aligned}
{d}_{k} &amp; ={y}_{k}-{\hat{m}}_{k},\quad\textrm{the innovation},\\
{S}_{k} &amp; =\hat{{P}}_{k}+{R},\quad\textrm{the measurement covariance},\\
{K}_{k} &amp; =\hat{{P}}_{k}{S}_{k}^{-1},\quad\textrm{the Kalman gain,}
\end{aligned}\]</span></p>
</section>
<section id="section-9" class="slide level2 center">
<h2></h2>
<p>then update, <span class="math display">\[\begin{aligned}
{m}_{k} &amp; ={\hat{m}}_{k}+K_{k}{d}_{k},\\
P_{k} &amp; =\hat{P}_{k}-\frac{\hat{P}_{k}^{2}}{S_{k}}.
\end{aligned}\]</span></p>
<p>In <a href="#/fig-KF_GRW" class="quarto-xref">Figure&nbsp;2</a>, we show simulations with system noise standard deviation of <span class="math inline">\(1\)</span> and measurement noise standard deviation of <span class="math inline">\(0.5.\)</span> We observe that the KF tracks the random walk very efficiently.</p>

<img data-src="../images/KF_GRW.png" style="width:35.0%" class="r-stretch quarto-figure-center"><p class="caption">
Figure&nbsp;2: Kalman filter for tracking a Gaussian random walk state space model <a href="#/kf-for-gaussian-random-walk" class="quarto-xref">4</a>“. State, <span class="math inline">\(x_k\)</span>, is solid blue curve; measurements, <span class="math inline">\(y_k\)</span>, are red circles; Kalman filter estimate is green curve and <span class="math inline">95</span>% quantiles are shown. Fixed values of noise variances are <span class="math inline">\(Q=1\)</span> and <span class="math inline">\(R=0.5^2\)</span>. Results computed by <code>kf_gauss_state.m</code>.
</p></section>
<section id="code-1" class="slide level2 center">
<h2>Code</h2>
<div class="columns">
<div class="column" style="width:60%;">
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource {matlab} number-lines code-with-copy"><code class="sourceCode"><span id="cb2-1"><a></a>%&nbsp;Kalman&nbsp;Filter&nbsp;for&nbsp;scalar&nbsp;Gaussian&nbsp;random&nbsp;walk</span>
<span id="cb2-2"><a></a>%&nbsp;Set&nbsp;parameters</span>
<span id="cb2-3"><a></a>sig_w&nbsp;=&nbsp;1;&nbsp;sig_v&nbsp;=&nbsp;0.5;</span>
<span id="cb2-4"><a></a>M&nbsp;=&nbsp;1;</span>
<span id="cb2-5"><a></a>Q&nbsp;=&nbsp;sig_w\^2;</span>
<span id="cb2-6"><a></a>H&nbsp;=&nbsp;1;</span>
<span id="cb2-7"><a></a>R&nbsp;=&nbsp;sig_v\^2;</span>
<span id="cb2-8"><a></a>%&nbsp;Initialize</span>
<span id="cb2-9"><a></a>m0&nbsp;=&nbsp;0;</span>
<span id="cb2-10"><a></a>P0&nbsp;=&nbsp;1;</span>
<span id="cb2-11"><a></a>%&nbsp;Simulate&nbsp;data</span>
<span id="cb2-12"><a></a>randn('state',1234);</span>
<span id="cb2-13"><a></a>steps&nbsp;=&nbsp;100;&nbsp;T&nbsp;=&nbsp;\[1:steps\];</span>
<span id="cb2-14"><a></a>X&nbsp;=&nbsp;zeros(1,steps);</span>
<span id="cb2-15"><a></a>Y&nbsp;=&nbsp;zeros(1,steps);</span>
<span id="cb2-16"><a></a>x&nbsp;=&nbsp;m0;</span>
<span id="cb2-17"><a></a>for&nbsp;k=1:steps</span>
<span id="cb2-18"><a></a>&nbsp;&nbsp;w&nbsp;=&nbsp;Q'\*randn(1);</span>
<span id="cb2-19"><a></a>&nbsp;&nbsp;x&nbsp;=&nbsp;M\*x&nbsp;+&nbsp;w;</span>
<span id="cb2-20"><a></a>&nbsp;&nbsp;y&nbsp;=&nbsp;H\*x&nbsp;+&nbsp;sig_v\*randn(1);</span>
<span id="cb2-21"><a></a>&nbsp;&nbsp;X(k)&nbsp;=&nbsp;x;</span>
<span id="cb2-22"><a></a>&nbsp;&nbsp;Y(k)&nbsp;=&nbsp;y;</span>
<span id="cb2-23"><a></a>end</span>
<span id="cb2-24"><a></a>plot(T,X,'-',T,Y,'.');</span>
<span id="cb2-25"><a></a>legend('Signal','Measurements');</span>
<span id="cb2-26"><a></a>xlabel('{k}');&nbsp;ylabel('{x}\_k');</span>
<span id="cb2-27"><a></a>%&nbsp;Kalman&nbsp;filter</span>
<span id="cb2-28"><a></a>m&nbsp;=&nbsp;m0;</span>
<span id="cb2-29"><a></a>P&nbsp;=&nbsp;P0;</span>
<span id="cb2-30"><a></a>for&nbsp;k=1:steps</span>
<span id="cb2-31"><a></a>&nbsp;&nbsp;m&nbsp;=&nbsp;M\*m;</span>
<span id="cb2-32"><a></a>&nbsp;&nbsp;P&nbsp;=&nbsp;M\*P\*M'&nbsp;+&nbsp;Q;</span>
<span id="cb2-33"><a></a>&nbsp;&nbsp;d&nbsp;=&nbsp;Y(:,k)&nbsp;-&nbsp;H\*m;</span>
<span id="cb2-34"><a></a>&nbsp;&nbsp;S&nbsp;=&nbsp;H\*P\*H'&nbsp;+&nbsp;R;</span>
<span id="cb2-35"><a></a>&nbsp;&nbsp;K&nbsp;=&nbsp;P\*H'/S;</span>
<span id="cb2-36"><a></a>&nbsp;&nbsp;m&nbsp;=&nbsp;m&nbsp;+&nbsp;K\*d;</span>
<span id="cb2-37"><a></a>&nbsp;&nbsp;P&nbsp;=&nbsp;P&nbsp;-&nbsp;K\*S\*K';</span>
<span id="cb2-38"><a></a>&nbsp;&nbsp;kf_m(k)&nbsp;=&nbsp;m;</span>
<span id="cb2-39"><a></a>&nbsp;&nbsp;kf_P(k)&nbsp;=&nbsp;P;</span>
<span id="cb2-40"><a></a>end</span>
<span id="cb2-41"><a></a>%&nbsp;Plot&nbsp;&nbsp;&nbsp;</span>
<span id="cb2-42"><a></a>clf;&nbsp;hold&nbsp;on</span>
<span id="cb2-43"><a></a>fill(\[T&nbsp;fliplr(T)\],\[kf_m+1.96\*sqrt(kf_P)&nbsp;\...</span>
<span id="cb2-44"><a></a>&nbsp;&nbsp;fliplr(kf_m-1.96\*sqrt(kf_P))\],1,&nbsp;\...</span>
<span id="cb2-45"><a></a>&nbsp;&nbsp;'FaceColor',\[.9&nbsp;.9&nbsp;.9\],'EdgeColor',\[.9&nbsp;.9&nbsp;.9\])</span>
<span id="cb2-46"><a></a>plot(T,X,'-b',T,Y,'or',T,&nbsp;kf_m(1,:),'-g')</span>
<span id="cb2-47"><a></a>plot(T,kf_m+1.96\*sqrt(kf_P),':r',T,kf_m-1.96\*sqrt(kf_P),':r');</span>
<span id="cb2-48"><a></a>hold&nbsp;off</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div><div class="column" style="width:40%;">
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Note</strong></p>
</div>
<div class="callout-content">
<ul>
<li><p>Line 3: by modifying these noise amplitudes, one can better understand how the KF operates.</p></li>
<li><p>Lines 31-32 and 34-38: the <span style="color: magenta">complete filter is coded in only 7 lines</span>, exactly as prescribed by Theorem <a href="#/thm:KF" data-reference-type="ref" data-reference="thm:KF">5</a>. This is the reason for the excellent performance of the KF, in particular in real-time systems. In higher dimensions, when the matrices become large, more attention must be paid to the numerical linear algebra routines used. The inversion of the measurement covariance matrix, <span class="math inline">\(S,\)</span> in line 36, is particularly challenging and requires highly tuned decomposition methods.</p></li>
</ul>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="section-10" class="slide level2 center">
<h2></h2>
<div class="center">
<p><strong><span style="color: blue">EXTENDED KALMAN FILTERS</span></strong></p>
</div>
</section>
<section id="extended-kalman-filters" class="slide level2 center">
<h2>Extended Kalman filters</h2>
<p>In real applications, we are usually confronted with <span style="color: magenta">nonlinearity</span> in the model and in the measurements.</p>
<ul>
<li>Moreover, the noise is not necessarily additive.</li>
</ul>
<p>To deal with these nonlinearities, one possible approach is to <span style="color: magenta">linearize</span> about the current mean and covariance, which produces the <span style="color: magenta"><em>extended Kalman filter</em></span> (EKF).</p>
<p>This filter is widely accepted as the <span style="color: magenta"><em>standard</em></span> for navigation and GPS systems, among others.</p>
<p>Recall the <span style="color: magenta">nonlinear problem</span>, <span id="eq-state_nl"><span class="math display">\[\begin{aligned}
\mathbf{x}_{k} &amp; = &amp; \mathcal{M}_{k-1}(\mathbf{x}_{k-1})+\mathbf{w}_{k-1},\label{eq:state_nl}\\
\mathbf{y}_{k} &amp; = &amp; \mathcal{H}_{k}(\mathbf{x}_{k})+\mathbf{v}_{k},\label{eq:obs_nl}
\end{aligned} \tag{5}\]</span></span> where</p>
</section>
<section id="section-11" class="slide level2 center">
<h2></h2>
<ul>
<li><p><span class="math inline">\(\mathbf{x}_{k}\in\mathbb{R}^{n},\)</span> <span class="math inline">\(\mathbf{y}_{k}\in\mathbb{R}^{m},\)</span> <span class="math inline">\(\mathbf{w}_{k-1}\sim\mathcal{N}(0,\mathbf{Q}_{k-1}),\)</span> <span class="math inline">\(\mathbf{v}_{k}\sim\mathcal{N}(0,\mathbf{R}_{k}),\)</span></p></li>
<li><p>and now <span class="math inline">\(\mathcal{M}_{k-1}\)</span> and <span class="math inline">\(\mathcal{H}_{k}\)</span> are <span style="color: magenta">nonlinear functions</span> of <span class="math inline">\(\mathbf{x}_{k-1}\)</span> and <span class="math inline">\(\mathbf{x}_{k}\)</span> respectively.</p></li>
</ul>
<p>The EKF is then based on <span style="color: magenta">Gaussian approximations</span> of the filtering densities, <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k})\approx\mathcal{N}\left(\mathbf{x}_{k}\mid\mathbf{m}_{k},\mathbf{P}_{k}\right),\]</span> where these approximations are derived from the <span style="color: magenta">first-order truncation</span> of the corresponding Taylor series in terms of the statistical moments of the underlying random variables.</p>
<p>Linearization in the Taylor series expansions will require evaluation of the <span style="color: magenta">Jacobian matrices</span>, defined as <span class="math display">\[\mathbf{M}_{\mathbf{x}}=\left[\frac{\partial\mathcal{M}}{\partial\mathbf{x}}\right]_{\mathbf{x}=\mathbf{m}}\]</span> and</p>
</section>
<section id="section-12" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[\mathbf{H}_{\mathbf{x}}=\left[\frac{\partial\mathcal{H}}{\partial\mathbf{x}}\right]_{\mathbf{x}=\mathbf{m}}.\]</span></p>
<div id="thm-EKF" class="theorem">
<p><span class="theorem-title"><strong>Theorem 3</strong></span> <em>The first-order <span style="color: magenta">extended Kalman filter</span> with <span style="color: magenta">additive noise</span> for the nonlinear system <a href="#/extended-kalman-filters" class="quarto-xref">5</a> can be computed by the three-stage process:</em></p>
<p><strong>Initialization</strong>: Define the <span style="color: magenta">prior</span> mean <span class="math inline">\(\mathbf{m}_{0}\)</span> and prior covariance <span class="math inline">\(\mathbf{P}_{0}.\)</span>*</p>
<p><strong>Prediction:</strong> <em>Compute the <span style="color: magenta">predictive</span> distribution mean and covariance,</em> <span class="math display">\[\begin{aligned}
\mathbf{\hat{m}}_{k} &amp; =\mathcal{M}_{k-1}(\mathbf{m}_{k-1}),\\
\hat{\mathbf{P}}_{k} &amp; =\mathbf{M}_{\mathbf{x}}(\mathbf{m}_{k-1})\mathbf{P}_{k-1}\mathbf{M}_{\mathbf{x}}^{\mathrm{T}}(\mathbf{m}_{k-1})+\mathbf{Q}_{k-1}.
\end{aligned}\]</span></p>
<p><strong>Correction</strong>: <em>Compute the <span style="color: magenta">filtering</span> distribution mean and covariance by first defining</em> <span class="math display">\[\begin{aligned}
\mathbf{d}_{k} &amp; =\mathbf{y}_{k}-\mathcal{H}_{k}(\mathbf{\hat{m}}_{k}),\quad\textrm{the innovation},\\
\mathbf{S}_{k} &amp; =\mathbf{H}_{\mathbf{x}}(\mathbf{\hat{m}}_{k})\hat{\mathbf{P}}_{k}\mathbf{H}_{\mathbf{x}}^{\mathrm{T}}(\mathbf{\hat{m}}_{k})+\mathbf{R}_{k},\thinspace\textrm{the measurement covariance},\\
\mathbf{K}_{k} &amp; =\hat{\mathbf{P}}_{k}\mathbf{H}_{\mathbf{x}}^{\mathrm{T}}(\mathbf{\hat{m}}_{k})\mathbf{S}_{k}^{-1},\quad\textrm{the Kalman gain,}
\end{aligned}\]</span></p>
</div>
</section>
<section id="section-13" class="slide level2 center">
<h2></h2>
<p><em>then finally <span style="color: magenta">updating</span> the filter mean and covariance,</em> <span class="math display">\[\begin{aligned}
\mathbf{m}_{k} &amp; =\mathbf{\hat{m}}_{k}+\mathbf{K}_{k}\mathbf{d}_{k},\\
\mathbf{P}_{k} &amp; =\hat{\mathbf{P}}_{k}-\mathbf{K}_{k}\mathbf{S}_{k}\mathbf{K}_{k}^{\mathrm{T}}.
\end{aligned}\]</span></p>
<div class="{proof}">
<p><em>Proof.</em> The proof see <span class="citation" data-cites="sarkka2013">Särkkä and Svensson (<a href="#/references" role="doc-biblioref" onclick="">2023</a>)</span> is once again a direct application of classical results for the joint, marginal and conditional distributions of two Gaussian random variables, <span class="math inline">\(\mathbf{x}_{k}\in\mathbb{R}^{n}\)</span> and <span class="math inline">\(\mathbf{y}_{k}\in\mathbb{R}^{m}.\)</span> In addition, use is made of the Taylor series approximations to compute the Jacobian matrices <span class="math inline">\(\mathbf{M}_{\mathbf{x}}\)</span> and <span class="math inline">\(\mathbf{H}_{\mathbf{x}}\)</span> evaluated at <span class="math inline">\(\mathbf{x}=\mathbf{\hat{m}}_{k-1}\)</span> and <span class="math inline">\(\mathbf{x}=\mathbf{\hat{m}}_{k}\)</span> respectively.&nbsp;</p>
</div>
</section>
<section id="extended-kalman-filter-non-additive-noise" class="slide level2 center">
<h2>Extended Kalman filter — non-additive noise</h2>
<p>For <span style="color: magenta">non-additive noise</span>, the model is now <span id="eq-state_nl_na"><span class="math display">\[\begin{aligned}
\mathbf{x}_{k} &amp; =\mathcal{M}_{k-1}(\mathbf{x}_{k-1},\mathbf{w}_{k-1}),\label{eq:state_nl_na}\\
\mathbf{y}_{k} &amp; =\mathcal{H}_{k}(\mathbf{x}_{k},\mathbf{v}_{k}),\label{eq:obs_nl_na}
\end{aligned} \tag{6}\]</span></span> where <span class="math inline">\(\mathbf{w}_{k-1}\sim\mathcal{N}(0,\mathbf{Q}_{k-1}),\)</span> and <span class="math inline">\(\mathbf{v}_{k}\sim\mathcal{N}(0,\mathbf{R}_{k})\)</span> are system and measurement Gaussian noises.</p>
<p>In this case the overall three-stage scheme is the same, with necessary modifications to take into account the additional functional dependence on <span class="math inline">\(\mathbf{w}\)</span> and <span class="math inline">\(\mathbf{v}.\)</span></p>
<dl>
<dt>Initialization:</dt>
<dd>
<p>Define the <span style="color: magenta">prior</span> mean <span class="math inline">\(\mathbf{m}_{0}\)</span> and prior covariance <span class="math inline">\(\mathbf{P}_{0}.\)</span></p>
</dd>
<dt>Prediction:</dt>
<dd>
<p>Compute the <span style="color: magenta">predictive</span> distribution mean and covariance,</p>
</dd>
</dl>
</section>
<section id="section-14" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[\begin{aligned}
    \mathbf{\hat{m}}_{k} &amp; =\mathcal{M}_{k-1}(\mathbf{m}_{k-1},\mathbf{0}),\\
    \hat{\mathbf{P}}_{k} &amp; =\mathbf{M}_{\mathbf{x}}(\mathbf{m}_{k-1})\mathbf{P}_{k-1}\mathbf{M}_{\mathbf{x}}^{\mathrm{T}}(\mathbf{m}_{k-1})\\
     &amp; +\mathbf{M}_{\mathbf{w}}(\mathbf{m}_{k-1})\mathbf{Q}_{k-1}\mathbf{M}_{\mathbf{w}}^{\mathrm{T}}(\mathbf{m}_{k-1})+\mathbf{Q}_{k-1}.
    \end{aligned}\]</span></p>
<dl>
<dt>Correction:</dt>
<dd>
<p>Compute the <span style="color: magenta">filtering</span> distribution mean and covariance by first defining <span class="math display">\[\begin{aligned}
\mathbf{d}_{k} &amp; =\mathbf{y}_{k}-\mathcal{H}_{k}(\mathbf{\hat{m}}_{k},\mathbf{0}),\,\textrm{the}\,\textrm{innovation},\\
\mathbf{S}_{k} &amp; =\mathbf{H}_{\mathbf{x}}(\mathbf{\hat{m}}_{k})\hat{\mathbf{P}}_{k}\mathbf{H}_{\mathbf{x}}^{\mathrm{T}}(\mathbf{\hat{m}}_{k})\\
&amp; +\mathbf{H}_{\mathbf{v}}(\mathbf{\hat{m}}_{k})\mathbf{R}_{k}\mathbf{H}_{\mathbf{v}}^{\mathrm{T}}(\mathbf{\hat{m}}_{k}),\,\textrm{the}\,\textrm{measurement\,covariance},\\
\mathbf{K}_{k} &amp; =\hat{\mathbf{P}}_{k}\mathbf{H}_{\mathbf{x}}^{\mathrm{T}}(\mathbf{\hat{m}}_{k})\mathbf{S}_{k}^{-1},\,\textrm{the}\,\textrm{Kalman\,gain,}
\end{aligned}\]</span> then finally <span style="color: magenta">updating</span> the filter mean and covariance, <span class="math display">\[\begin{aligned}
\mathbf{m}_{k} &amp; =\mathbf{\hat{m}}_{k}+\mathbf{K}_{k}\mathbf{d}_{k},\\
\mathbf{P}_{k} &amp; =\hat{\mathbf{P}}_{k}-\mathbf{K}_{k}\mathbf{S}_{k}\mathbf{K}_{k}^{\mathrm{T}}.
\end{aligned}\]</span></p>
</dd>
</dl>
</section>
<section id="ekf-pros-and-cons" class="slide level2 center">
<h2>EKF — pros and cons</h2>
<p><strong>Pros:</strong></p>
<ul>
<li><p>Relative <span style="color: magenta">simplicity</span>, based on well-known linearization methods.</p></li>
<li><p>Maintains the simple, elegant, and computationally <span style="color: magenta">efficient</span> KF update equations.</p></li>
<li><p>Good <span style="color: magenta">performance</span> for such a simple method.</p></li>
<li><p>Ability to treat <span style="color: magenta">nonlinear</span> process and observation models.</p></li>
<li><p>Ability to treat both <span style="color: magenta">additive</span> <span style="color: magenta">and more general nonlinear Gaussian noise</span>.</p></li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><p>Performance can suffer in presence of strong nonlinearity because of the <span style="color: magenta">local validity</span> of the linear approximation (valid for small perturbations around the linear term).</p></li>
<li><p>Cannot deal with <span style="color: magenta">non-Gaussian noise</span>, such as discrete-valued random variables.</p></li>
</ul>
</section>
<section id="section-15" class="slide level2 center">
<h2></h2>
<ul>
<li>Requires <span style="color: magenta">differentiable</span> process and measurement operators and evaluation of <span style="color: magenta">Jacobian</span> matrices, which might be problematic in very high dimensions.</li>
</ul>
<p>In spite of this, the EKF remains a solid filter and, as mentioned earlier, remains the basis of most GPS and navigation systems.</p>
</section>
<section id="ekf-example-nonlinear-oscillator" class="slide level2 center">
<h2>EKF Example — nonlinear oscillator</h2>
<p>Consider the <span style="color: magenta">nonlinear ODE</span> model for the oscillations of a noisy pendulum with unit mass and length <span class="math inline">\(L,\)</span> <span class="math display">\[\frac{\mathrm{d}^{2}\theta}{\mathrm{d}t^{2}}+\frac{g}{L}\sin\theta+w(t)=0\]</span> where</p>
<ul>
<li><p><span class="math inline">\(\theta\)</span> is the angular displacement of the pendulum,</p></li>
<li><p><span class="math inline">\(g\)</span> is the gravitational constant,</p></li>
<li><p><span class="math inline">\(L\)</span> is the pendulum’s length, and</p></li>
<li><p><span class="math inline">\(w(t)\)</span> is a white noise process.</p></li>
</ul>
<p>This is rewritten in <span style="color: magenta">state space</span> form, <span class="math display">\[\dot{\mathbf{x}}+\mathcal{M}(\mathbf{x})+\mathbf{w}=0,\]</span></p>
</section>
<section id="section-16" class="slide level2 center">
<h2></h2>
<p>where</p>
<p><span class="math display">\[\begin{aligned}
    \mathbf{x} &amp; =\left[\begin{array}{c}
    x_{1}\\
    x_{2}
    \end{array}\right]=\left[\begin{array}{c}
    \theta\\
    \dot{\theta}
    \end{array}\right],\quad\mathcal{M}(\mathbf{x})=\left[\begin{array}{c}
    x_{2}\\
    -\dfrac{g}{L}\sin x_{1}
    \end{array}\right],\\
    \mathbf{w} &amp; =\left[\begin{array}{c}
    0\\
    w(t)
    \end{array}\right].
    \end{aligned}\]</span></p>
<p>Suppose that we have <span style="color: magenta">discrete, noisy measurements</span> of the horizontal component of the position, <span class="math inline">\(\sin(\theta).\)</span></p>
<ul>
<li>Then the <span style="color: magenta">measurement equation</span> is scalar, <span class="math display">\[y_{k}=\sin\theta_{k}+v_{k},\]</span> where <span class="math inline">\(v_{k}\)</span> is a zero-mean Gaussian random variable with variance <span class="math inline">\(R.\)</span></li>
</ul>
<p>The system is thus <span style="color: magenta">nonlinear</span> in both state and measurement and the state-space system is of the general form <a href="#/extended-kalman-filters" class="quarto-xref">5</a>.</p>
</section>
<section id="section-17" class="slide level2 center">
<h2></h2>
<p>A simple <span style="color: magenta">discretization</span>, based on the simplest Euler’s method, produces <span class="math display">\[\begin{aligned}
    \mathbf{x}_{k} &amp; =\mathcal{M}(\mathbf{x}_{k-1})+\mathbf{w}_{k-1}\\
    {y}_{k} &amp; =\mathcal{H}_{k}(\mathbf{x}_{k})+{v}_{k},
    \end{aligned}\]</span> where <span class="math display">\[\begin{aligned}
    \mathbf{x}_{k} &amp; =\left[\begin{array}{c}
    x_{1}\\
    x_{2}
    \end{array}\right]_{k},\\
    \mathcal{M}(\mathbf{x}_{k-1}) &amp; =\left[\begin{array}{c}
    x_{1}+\Delta tx_{2}\\
    x_{2}-\Delta t\dfrac{g}{L}\sin x_{1}
    \end{array}\right]_{k-1},\\
    \mathcal{H}(\mathbf{x}_{k}) &amp; =[\sin x_{1}]_{k}.
    \end{aligned}\]</span></p>
<p>The <span style="color: magenta">noise terms</span> have distributions <span class="math display">\[\mathbf{w}_{k-1}\sim\mathcal{N}(\mathbf{0},Q),\quad v_{k}\sim\mathcal{N}(0,R),\]</span> where the <span style="color: magenta">process covariance matrix</span> is</p>
</section>
<section id="section-18" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[Q=\left[\begin{array}{cc}
    q_{11} &amp; q_{12}\\
    q_{21} &amp; q_{22}
    \end{array}\right],\]</span> with components (see remark below the example), <span class="math display">\[q_{11}=q_{c}\frac{\Delta t^{3}}{3},\quad q_{12}=q_{21}=q_{c}\frac{\Delta t^{2}}{2},\quad q_{22}=q_{c}\Delta t,\]</span> and <span class="math inline">\(q_{c}\)</span> is the continuous process noise spectral density.</p>
<p>For the <span style="color: magenta">first-order EKF</span> higher orders are possiblewe will need the <span style="color: magenta">Jacobian matrices</span> of <span class="math inline">\(\mathcal{M}(\mathbf{x})\)</span> and <span class="math inline">\(\mathcal{H}(\mathbf{x})\)</span> evaluated at <span class="math inline">\(\mathbf{x}=\mathbf{\hat{m}}_{k-1}\)</span> and <span class="math inline">\(\mathbf{x}=\mathbf{\hat{m}}_{k}\)</span> . These are easily obtained here, in an explicit form, <span class="math display">\[\mathbf{M}_{\mathbf{x}}=\left[\frac{\partial\mathcal{M}}{\partial\mathbf{x}}\right]_{\mathbf{x}=\mathbf{m}}=\left[\begin{array}{cc}
    1 &amp; \Delta t\\
    -\Delta t\dfrac{g}{L}\cos x_{1} &amp; 1
    \end{array}\right]_{k-1},\]</span></p>
</section>
<section id="section-19" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[\mathbf{H}_{\mathbf{x}}=\left[\frac{\partial\mathcal{H}}{\partial\mathbf{x}}\right]_{\mathbf{x}=\mathbf{m}}=\left[\begin{array}{cc}
\cos x_{1} &amp; 0\end{array}\right]_{k}.\]</span></p>
<p>For the <span style="color: magenta">simulations</span>, we take:</p>
<ul>
<li><p>500 time steps with <span class="math inline">\(\Delta t=0.01.\)</span></p></li>
<li><p>Noise levels <span class="math inline">\(q_{c}=0.01\)</span> and <span class="math inline">\(R=0.1.\)</span></p></li>
<li><p>Initial angle <span class="math inline">\(x_{1}=1.8\)</span> and initial angular velocity <span class="math inline">\(x_{2}=0.\)</span></p></li>
<li><p>Initial diagonal state covariance of <span class="math inline">\(0.1.\)</span></p></li>
</ul>
<p>Results are plotted in Figure <a href="#/fig-EKF_pendulum" class="quarto-xref">Figure&nbsp;3</a>.</p>
<ul>
<li>We notice that despite the very noisy, nonlinear measurements, the EKF rapidly approaches the true state and then tracks it extremely well.</li>
</ul>
</section>
<section id="section-20" class="slide level2 center">
<h2></h2>

<img data-src="../images/fig-EKF_pendulum.png" style="width:70.0%" class="r-stretch quarto-figure-center"><p class="caption">
Figure&nbsp;3: Extended Kalman filter for tracking a noisy pendulum model, where horizontal position is measured. State, <span class="math inline">\(x_k\)</span>, $is solid blue curve; measurements, <span class="math inline">\(y_k\)</span>, are red circles; extended Kalman filter estimate is green curve. Results computed by <code>EKfPendulum.m</code>
</p></section>
<section id="section-21" class="slide level2 center">
<h2></h2>
<div class="callout callout-note callout-titled callout-style-default">
<div class="callout-body">
<div class="callout-title">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<p><strong>Note</strong></p>
</div>
<div class="callout-content">
<p>In the above example, we have used a rather special form for the process noise covariance, <span class="math inline">\(Q.\)</span> It cannot be computed exactly for nonlinear systems and some kind of approximations are needed.<sup>1</sup> One way is to use an Euler-Maruyama method from SDEs, but this leads to singular dynamics where the particle smoothers will not work. Another approach, which was used here, is to first construct an approximate model and then compute the covariance using that model. In this case the approximate model was taken as <span class="math display">\[\ddot{x}=w(t),\]</span> which is maybe overly simple, but works. Then the matrix <span class="math inline">\(Q\)</span> is propagated through this simplified dynamics using an integration factor (exponential) solution and the corresponding power series expression of the transition matrix. Details of this can be found in [Grewal; Andrews].</p>
</div>
</div>
</div>
<aside><ol class="aside-footnotes"><li id="fn1"><p>Thanks to Simo Särkkä (private communication) for suggesting this explanation.</p></li></ol></aside></section>
<section id="unscented-kalman-filters" class="slide level2 center">
<h2>Unscented Kalman filters</h2>
<p>The <em>unscented Kalman filter</em> (UKF) was developed to overcome two shortcomings of the EKF:</p>
<ol type="1">
<li><p>its difficulty to treat strong nonlinearities and</p></li>
<li><p>its reliance on the computation of Jacobians.</p></li>
</ol>
<p>The UKF is based on the <span style="color: magenta">unscented transform</span> (UT), a method for approximating the distribution of a transformed variable, <span class="math display">\[\mathbf{y}=g(\mathbf{x}),\]</span> where <span class="math inline">\(\mathbf{x}\sim\mathcal{N}(\mathbf{m},\mathbf{P}),\)</span> without linearizing the function <span class="math inline">\(g.\)</span></p>
<p>The UT is computed as follows:</p>
</section>
<section id="section-22" class="slide level2 center">
<h2></h2>
<ol type="1">
<li><p>Choose a collection of so-called<span style="color: magenta"><span class="math inline">\(\sigma\)</span>-points</span>that reproduce the mean and covariance of the distribution of <span class="math inline">\(\mathbf{x}\)</span>.</p></li>
<li><p>Apply the <span style="color: magenta">nonlinear</span>function to the <span class="math inline">\(\sigma\)</span>-points.</p></li>
<li><p>Estimate the<span style="color: magenta">mean and variance</span> of the transformed random variable.</p></li>
</ol>
<p>This is a <span style="color: magenta">deterministic sampling</span> approach, as opposed to Monte Carlo, particle filters, and ensemble filters that all use randomly sampled points. Note that the first two usually require orders of magnitude more points than the UKF.</p>
<p>Suppose that the random variable <span class="math inline">\(\mathbf{x}\in\mathbb{R}^{n}\)</span> with mean <span class="math inline">\(\mathbf{m}\)</span> and covariance <span class="math inline">\(\mathbf{P}.\)</span> Compute <span class="math inline">\(N=2n+1\)</span> <span class="math inline">\(\sigma\)</span>-points and their corresponding weights <span class="math display">\[\{\mathbf{x}^{(\pm i),},w^{(\pm i)}\},\quad i=0,1,\ldots,N\]</span> by the formulas</p>
</section>
<section id="section-23" class="slide level2 center">
<h2></h2>
<p><span class="math display">\[\begin{aligned}
\mathbf{x}^{(0)} &amp; =\mathbf{m},\\
\mathbf{x}^{(\pm i)} &amp; =\mathbf{m}\pm\sqrt{n+\lambda}\,\mathbf{p}^{(i)},\quad i=1,2,\ldots,n,\\
w^{(0)} &amp; =\frac{\lambda}{n+\lambda},\\
w^{(\pm i)} &amp; =\frac{\lambda}{2\left(n+\lambda\right)},\quad i=1,2,\ldots,n,
\end{aligned}\]</span> where</p>
<ul>
<li><p><span class="math inline">\(\mathbf{p}_{i}\)</span> is the <span class="math inline">\(i\)</span>-th column of the square root of <span class="math inline">\(\mathbf{P},\)</span> which is the matrix <span class="math inline">\(S\)</span> such that <span class="math inline">\(SS^{\mathrm{T}}=\mathbf{P},\)</span> sometimes denoted as <span class="math inline">\(\mathbf{P}^{1/2},\)</span></p></li>
<li><p><span class="math inline">\(\lambda\)</span> is a scaling parameter, defined as <span class="math display">\[\lambda=\alpha^{2}(n+\kappa)-n,\quad0&lt;\alpha&lt;1,\]</span></p></li>
<li><p><span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\kappa\)</span> describe the spread of the <span class="math inline">\(\sigma\)</span>-points around the mean, with <span class="math inline">\(\kappa=3-n\)</span> usually,</p></li>
<li><p><span class="math inline">\(\beta\)</span> is used to include prior information on non-Gaussian distributions of <span class="math inline">\(\mathbf{x}.\)</span></p></li>
</ul>
</section>
<section id="section-24" class="slide level2 center">
<h2></h2>
<p>For the covariance matrix, the weight <span class="math inline">\(w^{(0)}\)</span> is modified to <span class="math display">\[w^{(0)}=\frac{\lambda}{n+\lambda}+\left(1-\alpha^{2}+\beta\right).\]</span> These points and weights ensure that the means and covariances are consistently captured by the UT.</p>
</section>
<section id="ukf-algorithm" class="slide level2 center">
<h2>UKF — algorithm</h2>
<div id="thm-UKS" class="theorem">
<p><span class="theorem-title"><strong>Theorem 4</strong></span> <em>The UKF for the nonlinear system <a href="#/extended-kalman-filters" class="quarto-xref">5</a> computes a Gaussian approximation of the filtering distribution <span class="math display">\[p(\mathbf{x}_{k}\mid\mathbf{y}_{1:k})\approx\mathcal{N}\left(\mathbf{x}_{k}\mid\mathbf{m}_{k},\mathbf{P}_{k}\right),\]</span> based on the UT, following the three-stage process:</em></p>
<p><em><strong>Initialization</strong>: Define the prior mean <span class="math inline">\(\mathbf{m}_{0},\)</span> prior covariance <span class="math inline">\(\mathbf{P}_{0}\)</span> and the parameters <span class="math inline">\(\alpha,\)</span> <span class="math inline">\(\beta,\)</span> <span class="math inline">\(\kappa.\)</span></em></p>
<p><em><strong>Prediction</strong>:</em></p>
<p><em>Compute the <span class="math inline">\(\sigma\)</span>-points and weights, <span class="math display">\[\begin{aligned}
\mathbf{x}_{k-1}^{(0)} &amp; =\mathbf{m}_{k-1},\\
\mathbf{x}_{k-1}^{(\pm i)} &amp; =\mathbf{m}_{k-1}\pm\sqrt{n+\lambda}\,\mathbf{p}_{k-1}^{(i)},\quad i=1,2,\ldots,n,\\
w^{(0)} &amp; =\frac{\lambda}{n+\lambda},\quad w^{(\pm i)}  =\frac{\lambda}{2\left(n+\lambda\right)},\quad i=1,2,\ldots,n.
\end{aligned}\]</span></em></p>
</div>
</section>
<section id="section-25" class="slide level2 center">
<h2></h2>
<p><em>Propagate the <span class="math inline">\(\sigma\)</span>-points through the dynamic model</em> <span class="math display">\[\tilde{\mathbf{x}}_{k}^{(i)}=\mathcal{M}_{k-1}\left(\mathbf{x}_{k-1}^{(i)}\right).\]</span></p>
<p><em>Compute the predictive distribution mean and covariance,</em> <span class="math display">\[\begin{aligned}
\mathbf{m}_{k}^{-} &amp; =\sum_{i=0}^{\pm n}w^{(i)}\tilde{\mathbf{x}}_{k}^{(i)}\\
\mathbf{P}_{k}^{-} &amp; =\sum_{i=0}^{\pm n}w^{(i)}\left(\tilde{\mathbf{x}}_{k}^{(i)}-\mathbf{m}_{k}^{-}\right)\left(\tilde{\mathbf{x}}_{k}^{(i)}-\mathbf{m}_{k}^{-}\right)^{\mathrm{T}}+\mathbf{Q}_{k-1}.
\end{aligned}\]</span></p>
</section>
<section id="section-26" class="slide level2 center">
<h2></h2>
<p><em><strong>Correction</strong>:</em></p>
<p><em>Compute the updated <span class="math inline">\(\sigma\)</span>-points and weights,</em> <span class="math display">\[\begin{aligned}
\mathbf{x}_{k}^{(0)} &amp; =\mathbf{m}_{k}^{-},\\
\mathbf{x}_{k}^{(\pm i)} &amp; =\mathbf{m}_{k}^{-}\pm\sqrt{n+\lambda}\,\mathbf{p}_{k}^{(i)-},\quad i=1,2,\ldots,n,\\
w^{(0)} &amp; =\frac{\lambda}{n+\lambda}+\left(1-\alpha^{2}+\beta\right),\\
w^{(\pm i)} &amp; =\frac{\lambda}{2\left(n+\lambda\right)},\quad i=1,2,\ldots,n.
\end{aligned}\]</span></p>
<p><em>Propagate the updated <span class="math inline">\(\sigma\)</span>-points through the measurement model</em> <span class="math display">\[\tilde{\mathbf{y}}_{k}^{(i)}=\mathcal{H}_{k}\left(\mathbf{x}_{k}^{(i)}\right).\]</span></p>
</section>
<section id="section-27" class="slide level2 center">
<h2></h2>
<p><em>Compute the predicted mean and innovation, predicted measurement covariance, state-measurement cross-covariance, and filter gain,</em> <span class="math display">\[\begin{aligned}
\boldsymbol{\mu}_{k} &amp; =\sum_{i=0}^{\pm n}w^{(i)}\tilde{\mathbf{y}}_{k}^{(i)},\quad\textrm{the mean,}\\
\mathbf{d}_{k} &amp; =\mathbf{y}_{k}-\boldsymbol{\mu}_{k},\quad\textrm{the innovation,}\\
\mathbf{S}_{k} &amp; =\sum_{i=0}^{\pm n}w^{(i)}\left(\tilde{\mathbf{y}}_{k}^{(i)}-\boldsymbol{\mu}_{k}\right)\left(\tilde{\mathbf{y}}_{k}^{(i)}-\boldsymbol{\mu}_{k}\right)^{\mathrm{T}}+\mathbf{R}_{k},\textrm{ measur cov}\\
\mathbf{C}_{k} &amp; =\sum_{i=0}^{\pm n}w^{(i)}\left({\mathbf{x}}_{k}^{(i)}-\mathbf{m}_{k}^{-}\right)\left(\tilde{\mathbf{y}}_{k}^{(i)}-\boldsymbol{\mu}_{k}\right)^{\mathrm{T}},\textrm{ s-m cross-cov},\\
\mathbf{K}_{k} &amp; =\mathbf{C}_{k}\mathbf{S}_{k}^{-1},\quad\textrm{the Kalman gain.}
\end{aligned}\]</span></p>
<p><em>Finally, <strong>update</strong> the filter mean and covariance, <span class="math display">\[\begin{aligned}
\mathbf{m}_{k} &amp; =\mathbf{\hat{m}}_{k}+\mathbf{K}_{k}\mathbf{d}_{k},\\
\mathbf{P}_{k} &amp; =\hat{\mathbf{P}}_{k}-\mathbf{K}_{k}\mathbf{S}_{k}\mathbf{K}_{k}^{\mathrm{T}}.
\end{aligned}\]</span></em></p>
</section>
<section id="section-28" class="slide level2 center">
<h2></h2>
<p>Just as was the case with the EKF, the UKF can also be applied to the non-additive noise model <a href="#/extended-kalman-filter-non-additive-noise" class="quarto-xref">6</a>.</p>
<ul>
<li>This is achieved by applying a non-additive version of the UT. Details can be found in <span class="citation" data-cites="sarkka2013">(<a href="#/references" role="doc-biblioref" onclick="">Särkkä and Svensson 2023</a>)</span>.</li>
</ul>
</section>
<section id="particle-filters" class="slide level2 center">
<h2>Particle filters</h2>
<p>What happens if both the models are nonlinear and the pdfs are non Gaussian?</p>
<p>The Kalman filter and its extensions are no longer optimal and, more importantly, can easily fail the estimation process. Another approach must be used.</p>
<p>A promising candidate is the <span style="color: magenta"><em>particle filter</em></span> (PF)</p>
<p>The particle filter <span class="citation" data-cites="doucet2009tutorial">(<a href="#/references" role="doc-biblioref" onclick="">Doucet, Johansen, et al. 2009</a>)</span> (and references therein) works sequentially in the spirit of the Kalman filter, but unlike the latter, it handles an ensemble of states (the particles) whose distribution approximates the pdf of the true state.</p>
<p>Bayes’ rule and the marginalization formula, <span class="math display">\[p(x)=\int p(x\mid y)p(y)\,\mathrm{d}y,\]</span> are explicitly used in the estimation process.</p>
<p>The linear and Gaussian hypotheses can then be ruled out, in theory.</p>
</section>
<section id="section-29" class="slide level2 center">
<h2></h2>
<p>In practice though, the particle filter cannot yet be applied to very high dimensional systems (this is often referred to as “the curse of dimensionality”). Though recent work by [Friedemann, Raffin2023] has improved this by sophisticated parallel computing.</p>
<p>Particle filters are methods for obtaining <span style="color: magenta"><em>Monte Carlo approximations</em></span>of the solutions of the Bayesian filtering equations.</p>
<p>Rather than trying to compute the exact solution of the Bayesian filtering equations, the transformations of such filtering (Bayes’ rule for the analysis, model propagation for the forecast) are applied to the members of the sample.</p>
<ul>
<li><p>The statistical moments are meant to be those of the targeted pdf.</p></li>
<li><p>Obviously this sampling strategy can only be exact in the asymptotic limit; that is, in the limit where the number of members (or particles) goes to infinity.</p></li>
</ul>
<p>The most popular and simple algorithm of Monte Carlo type that solves the Bayesian filtering equations is called the <span style="color: magenta"><em>bootstrap particle filter</em></span>. It is computed by a three-stage process.</p>
</section>
<section id="section-30" class="slide level2 center">
<h2></h2>
<dl>
<dt>Sampling</dt>
<dd>
<p>We consider a sample of particles <span class="math inline">\(\left\{ \mathbf{x}_{1},\mathbf{x}_{2},\ldots,\mathbf{x}_{M}\right\}\)</span>. The related probability density function at time <span class="math inline">\(t_{k}\)</span> is <span class="math inline">\(p_{k}(\mathbf{x}),\)</span> where <span class="math display">\[p_{k}(\mathbf{x})\simeq\sum_{i=1}^{M}\omega_{i}^{k}\delta(\mathbf{x}-\mathbf{x}_{k}^{i})\]</span> and <span class="math inline">\(\delta\)</span> is the Dirac mass and the sum is meant to be an approximation of the exact density that the samples emulate. A positive scalar, <span class="math inline">\(\omega_{k}^{i},\)</span> weights the importance of particle <span class="math inline">\(i\)</span> within the ensemble. At this stage, we assume that the weights <span class="math inline">\(\omega_{i}^{k}\)</span> are uniform and <span class="math inline">\(\omega_{i}^{k}=1/M\)</span></p>
</dd>
</dl>
</section>
<section id="section-31" class="slide level2 center">
<h2></h2>
<dl>
<dt>Forecast</dt>
<dd>
<p>At the forecast step, the particles are propagated by the model without approximation, <span class="math display">\[p_{k+1}(\mathbf{x})\simeq\sum_{i=1}^{M}\omega_{k}^{i}\delta(\mathbf{x}-\mathbf{x}_{k+1}^{i}),\]</span> with <span class="math inline">\(\mathbf{x}_{k+1}^{i}=\mathcal{M}_{k+1}(\mathbf{x}_{k}).\)</span> A stochastic noise can optionally be added to the dynamics of each particle.</p>
</dd>
</dl>
</section>
<section id="section-32" class="slide level2 center">
<h2></h2>
<dl>
<dt>Analysis</dt>
<dd>
<p>The analysis step of the particle filter is extremely simple and elegant. The rigorous implementation of Bayes’ rule ascribes to each particle a statistical weight that corresponds to the likelihood of the particle given the data. The weight of each particle is updated according to <span class="math display">\[\omega_{k+1}^{\mathrm{a},i}\propto\omega_{k+1}^{\mathrm{f},i}p(\mathbf{y}_{k+1}|\mathbf{x}_{k+1}^{i})\,.\]</span> It is remarkable that the analysis is carried out with only a few multiplications. It does not involve inverting any system or matrix, as opposed for instance to the Kalman filter.</p>
</dd>
</dl>
</section>
<section id="choosing-a-filter" class="slide level2 center">
<h2>Choosing a Filter</h2>
<p>One usually has to choose between</p>
<ul>
<li><p>linear Kalman filters</p></li>
<li><p>ensemble Kalman filters</p></li>
<li><p>nonlinear filters</p></li>
<li><p>hybrid variational-filter methods.</p></li>
</ul>
</section>
<section id="section-33" class="slide level2 center">
<h2></h2>
<p>These questions are resumed in the following Table:</p>
<div id="tbl-KFcomp" class="quarto-float">
<figure class="quarto-float quarto-float-tbl">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-KFcomp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1: Decision matrix for choice of Kalman filters.
</figcaption>
<div aria-describedby="tbl-KFcomp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Estimator</th>
<th style="text-align: center;">Model type</th>
<th style="text-align: center;">pdf</th>
<th style="text-align: center;">CPU-time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">KF</td>
<td style="text-align: center;">linear</td>
<td style="text-align: center;">Gaussian</td>
<td style="text-align: center;">low</td>
</tr>
<tr class="even">
<td style="text-align: center;">EKF</td>
<td style="text-align: center;">locally linear</td>
<td style="text-align: center;">Gaussian</td>
<td style="text-align: center;">low-medium</td>
</tr>
<tr class="odd">
<td style="text-align: center;">UKF</td>
<td style="text-align: center;">nonlinear</td>
<td style="text-align: center;">Gaussian</td>
<td style="text-align: center;">medium</td>
</tr>
<tr class="even">
<td style="text-align: center;">EnKF</td>
<td style="text-align: center;">nonlinear</td>
<td style="text-align: center;">Gaussian</td>
<td style="text-align: center;">medium-high</td>
</tr>
<tr class="odd">
<td style="text-align: center;">PF</td>
<td style="text-align: center;">nonlinear</td>
<td style="text-align: center;">non-Gaussian</td>
<td style="text-align: center;">high</td>
</tr>
</tbody>
</table>
</div>
</figure>
</div>
</section>
<section id="codes" class="slide level2 center">
<h2>Codes</h2>
<p>Various open-source repositories and codes are available for both academic and operational data assimilation.</p>
<ol type="1">
<li><p>DARC: <a href="https://research.reading.ac.uk/met-darc/" class="uri">https://research.reading.ac.uk/met-darc/</a> from Reading, UK.</p></li>
<li><p>DAPPER: <a href="https://github.com/nansencenter/DAPPER" class="uri">https://github.com/nansencenter/DAPPER</a> from Nansen, Norway.</p></li>
<li><p>DART: <a href="https://dart.ucar.edu/" class="uri">https://dart.ucar.edu/</a> from NCAR, US, specialized in ensemble DA.</p></li>
<li><p>OpenDA: <a href="https://www.openda.org/" class="uri">https://www.openda.org/</a>.</p></li>
<li><p>Verdandi: <a href="http://verdandi.sourceforge.net/" class="uri">http://verdandi.sourceforge.net/</a> from INRIA, France.</p></li>
<li><p>PyDA: <a href="https://github.com/Shady-Ahmed/PyDA" class="uri">https://github.com/Shady-Ahmed/PyDA</a>, a Python implementation for academic use.</p></li>
<li><p>Filterpy: <a href="https://github.com/rlabbe/filterpy" class="uri">https://github.com/rlabbe/filterpy</a>, dedicated to KF variants.</p></li>
<li><p>EnKF; <a href="https://enkf.nersc.no/" class="uri">https://enkf.nersc.no/</a>, the original Ensemble KF from Geir Evensen.</p></li>
</ol>
</section>
<section id="references" class="title-slide slide level1 unnumbered smaller scrollable">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-doucet2009tutorial" class="csl-entry" role="listitem">
Doucet, Arnaud, Adam M Johansen, et al. 2009. <span>“A Tutorial on Particle Filtering and Smoothing: Fifteen Years Later.”</span> <em>Handbook of Nonlinear Filtering</em> 12 (656-704): 3.
</div>
<div id="ref-sarkka2013" class="csl-entry" role="listitem">
Särkkä, Simo, and Lennart Svensson. 2023. <em>Bayesian Filtering and Smoothing</em>. Vol. 17. Cambridge university press.
</div>
</div>

<div class="quarto-auto-generated-content">
<p><img src="images/logo.png" class="slide-logo"></p>
<div class="footer footer-default">
<p><a href="https://flexie.github.io/CSE-8803-Twin/">🔗 https://flexie.github.io/CSE-8803-Twin/</a></p>
</div>
</div>
</section>


    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../../site_libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="../../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":true},
'smaller': true,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'fade',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
      function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
        const config = {
          allowHTML: true,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start',
        };
        if (contentFn) {
          config.content = contentFn;
        }
        if (onTriggerFn) {
          config.onTrigger = onTriggerFn;
        }
        if (onUntriggerFn) {
          config.onUntrigger = onUntriggerFn;
        }
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          return note.innerHTML;
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>